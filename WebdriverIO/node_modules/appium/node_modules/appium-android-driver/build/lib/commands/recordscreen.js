'use strict';

var _toConsumableArray = require('babel-runtime/helpers/to-consumable-array')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _fs2 = require('fs');

var _fs3 = _interopRequireDefault(_fs2);

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

var _asyncbox = require('asyncbox');

var _appiumSupport = require('appium-support');

var _logger = require('../logger');

var _logger2 = _interopRequireDefault(_logger);

var _teen_process = require('teen_process');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _v8 = require('v8');

var _v82 = _interopRequireDefault(_v8);

var commands = {},
    extensions = {};

var RETRY_PAUSE = 300;
var RETRY_TIMEOUT = 5000;
var MAX_RECORDING_TIME_SEC = 60 * 3;
var MAX_TIME_SEC = 60 * 30;
var DEFAULT_RECORDING_TIME_SEC = MAX_RECORDING_TIME_SEC;
var PROCESS_SHUTDOWN_TIMEOUT = 10 * 1000;
var SCREENRECORD_BINARY = 'screenrecord';
var DEFAULT_EXT = '.mp4';
var MIN_EMULATOR_API_LEVEL = 27;
var FFMPEG_BINARY = 'ffmpeg' + (_appiumSupport.system.isWindows() ? '.exe' : '');

function uploadRecordedMedia(adb, localFile) {
  var remotePath = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
  var uploadOptions = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];

  var _ref, size, maxMemoryLimit, remoteUrl, options, user, pass, method;

  return _regeneratorRuntime.async(function uploadRecordedMedia$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.stat(localFile));

      case 2:
        _ref = context$1$0.sent;
        size = _ref.size;

        _logger2['default'].debug('The size of the resulting screen recording is ' + _appiumSupport.util.toReadableSizeString(size));

        if (!_lodash2['default'].isEmpty(remotePath)) {
          context$1$0.next = 11;
          break;
        }

        maxMemoryLimit = _v82['default'].getHeapStatistics().total_available_size / 2;

        if (size >= maxMemoryLimit) {
          _logger2['default'].info('The file might be too large to fit into the process memory ' + ('(' + _appiumSupport.util.toReadableSizeString(size) + ' >= ' + _appiumSupport.util.toReadableSizeString(maxMemoryLimit) + '). ') + 'Provide a link to a remote writable location for video upload ' + '(http(s) and ftp protocols are supported) if you experience Out Of Memory errors');
        }
        context$1$0.next = 10;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.readFile(localFile));

      case 10:
        return context$1$0.abrupt('return', context$1$0.sent.toString('base64'));

      case 11:
        remoteUrl = _url2['default'].parse(remotePath);
        options = {};
        user = uploadOptions.user;
        pass = uploadOptions.pass;
        method = uploadOptions.method;

        if (remoteUrl.protocol.startsWith('http')) {
          options = {
            url: remoteUrl.href,
            method: method || 'PUT',
            multipart: [{ body: _fs3['default'].createReadStream(localFile) }]
          };
          if (user && pass) {
            options.auth = { user: user, pass: pass };
          }
        } else if (remoteUrl.protocol.startsWith('ftp')) {
          options = {
            host: remoteUrl.hostname,
            port: remoteUrl.port || 21
          };
          if (user && pass) {
            options.user = user;
            options.pass = pass;
          }
        }
        context$1$0.next = 19;
        return _regeneratorRuntime.awrap(_appiumSupport.net.uploadFile(localFile, remotePath, options));

      case 19:
        return context$1$0.abrupt('return', '');

      case 20:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function verifyScreenRecordIsSupported(adb, isEmulator) {
  var apiLevel;
  return _regeneratorRuntime.async(function verifyScreenRecordIsSupported$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(adb.getApiLevel());

      case 2:
        apiLevel = context$1$0.sent;

        if (!(isEmulator && apiLevel < MIN_EMULATOR_API_LEVEL)) {
          context$1$0.next = 5;
          break;
        }

        throw new Error('Screen recording does not work on emulators running Android API level less than ' + MIN_EMULATOR_API_LEVEL);

      case 5:
        if (!(apiLevel < 19)) {
          context$1$0.next = 7;
          break;
        }

        throw new Error('Screen recording not available on API Level ' + apiLevel + '. Minimum API Level is 19.');

      case 7:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function scheduleScreenRecord(adb, recordingProperties) {
  var startTimestamp, videoSize, bitRate, timeLimit, bugReport, currentTimeLimit, currentTimeLimitInt, pathOnDevice, recordingProc;
  return _regeneratorRuntime.async(function scheduleScreenRecord$(context$1$0) {
    var _this = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (!recordingProperties.stopped) {
          context$1$0.next = 2;
          break;
        }

        return context$1$0.abrupt('return');

      case 2:
        startTimestamp = recordingProperties.startTimestamp;
        videoSize = recordingProperties.videoSize;
        bitRate = recordingProperties.bitRate;
        timeLimit = recordingProperties.timeLimit;
        bugReport = recordingProperties.bugReport;
        currentTimeLimit = MAX_RECORDING_TIME_SEC;

        if (_appiumSupport.util.hasValue(recordingProperties.currentTimeLimit)) {
          currentTimeLimitInt = parseInt(recordingProperties.currentTimeLimit, 10);

          if (!isNaN(currentTimeLimitInt) && currentTimeLimitInt < MAX_RECORDING_TIME_SEC) {
            currentTimeLimit = currentTimeLimitInt;
          }
        }
        pathOnDevice = '/sdcard/' + Math.floor(new Date()) + DEFAULT_EXT;
        recordingProc = adb.screenrecord(pathOnDevice, {
          videoSize: videoSize,
          bitRate: bitRate,
          timeLimit: currentTimeLimit,
          bugReport: bugReport
        });

        recordingProc.on('end', function () {
          if (recordingProperties.stopped || !_appiumSupport.util.hasValue(timeLimit)) {
            return;
          }
          var currentDuration = process.hrtime(startTimestamp)[0];
          _logger2['default'].debug('The overall screen recording duration is ' + currentDuration + 's so far');
          var timeLimitInt = parseInt(timeLimit, 10);
          if (isNaN(timeLimitInt) || currentDuration >= timeLimitInt) {
            _logger2['default'].debug('There is no need to start the next recording chunk');
            return;
          }

          recordingProperties.currentTimeLimit = timeLimitInt - currentDuration;
          var chunkDuration = recordingProperties.currentTimeLimit < MAX_RECORDING_TIME_SEC ? recordingProperties.currentTimeLimit : MAX_RECORDING_TIME_SEC;
          _logger2['default'].debug('Starting the next ' + chunkDuration + 's-chunk ' + ('of screen recording in order to achieve ' + timeLimitInt + 's total duration'));
          scheduleScreenRecord(adb, recordingProperties)['catch'](function (e) {
            _logger2['default'].error(e.stack);
            recordingProperties.stopped = true;
          });
        });

        context$1$0.next = 14;
        return _regeneratorRuntime.awrap(recordingProc.start(0));

      case 14:
        context$1$0.prev = 14;
        context$1$0.next = 17;
        return _regeneratorRuntime.awrap((0, _asyncbox.waitForCondition)(function callee$1$0() {
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.next = 2;
                return _regeneratorRuntime.awrap(adb.fileExists(pathOnDevice));

              case 2:
                return context$2$0.abrupt('return', context$2$0.sent);

              case 3:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this);
        }, { waitMs: RETRY_TIMEOUT, intervalMs: RETRY_PAUSE }));

      case 17:
        context$1$0.next = 22;
        break;

      case 19:
        context$1$0.prev = 19;
        context$1$0.t0 = context$1$0['catch'](14);
        throw new Error('The expected screen record file \'' + pathOnDevice + '\' does not exist after ' + RETRY_TIMEOUT + 'ms');

      case 22:

        recordingProperties.records.push(pathOnDevice);
        recordingProperties.recordingProcess = recordingProc;

      case 24:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[14, 19]]);
}

function mergeScreenRecords(mediaFiles) {
  var configContent, configFile, result, args;
  return _regeneratorRuntime.async(function mergeScreenRecords$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.which(FFMPEG_BINARY));

      case 3:
        context$1$0.next = 8;
        break;

      case 5:
        context$1$0.prev = 5;
        context$1$0.t0 = context$1$0['catch'](0);
        throw new Error(FFMPEG_BINARY + ' utility is not available in PATH. Please install it from https://www.ffmpeg.org/');

      case 8:
        configContent = mediaFiles.map(function (x) {
          return 'file \'' + x + '\'';
        }).join('\n');
        configFile = _path2['default'].resolve(_path2['default'].dirname(mediaFiles[0]), 'config.txt');
        context$1$0.next = 12;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.writeFile(configFile, configContent, 'utf8'));

      case 12:
        _logger2['default'].debug('Generated ffmpeg merging config \'' + configFile + '\' with items:\n' + configContent);
        result = _path2['default'].resolve(_path2['default'].dirname(mediaFiles[0]), 'merge_' + Math.floor(new Date()) + DEFAULT_EXT);
        args = ['-safe', '0', '-f', 'concat', '-i', configFile, '-c', 'copy', result];

        _logger2['default'].info('Initiating screen records merging using the command \'' + FFMPEG_BINARY + ' ' + args.join(' ') + '\'');
        context$1$0.next = 18;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(FFMPEG_BINARY, args));

      case 18:
        return context$1$0.abrupt('return', result);

      case 19:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 5]]);
}

function terminateBackgroundScreenRecording(adb) {
  var force = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];
  var pids;
  return _regeneratorRuntime.async(function terminateBackgroundScreenRecording$(context$1$0) {
    var _this2 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(adb.getPIDsByName(SCREENRECORD_BINARY));

      case 2:
        context$1$0.t0 = function (p) {
          return '' + p;
        };

        pids = context$1$0.sent.map(context$1$0.t0);

        if (!_lodash2['default'].isEmpty(pids)) {
          context$1$0.next = 6;
          break;
        }

        return context$1$0.abrupt('return', false);

      case 6:
        context$1$0.prev = 6;
        context$1$0.next = 9;
        return _regeneratorRuntime.awrap(adb.shell(['kill', force ? '-15' : '-2'].concat(_toConsumableArray(pids))));

      case 9:
        context$1$0.next = 11;
        return _regeneratorRuntime.awrap((0, _asyncbox.waitForCondition)(function callee$1$0() {
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.t0 = _lodash2['default'];
                context$2$0.next = 3;
                return _regeneratorRuntime.awrap(adb.getPIDsByName(SCREENRECORD_BINARY));

              case 3:
                context$2$0.t1 = context$2$0.sent;
                return context$2$0.abrupt('return', context$2$0.t0.isEmpty.call(context$2$0.t0, context$2$0.t1));

              case 5:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this2);
        }, {
          waitMs: PROCESS_SHUTDOWN_TIMEOUT,
          intervalMs: 500
        }));

      case 11:
        return context$1$0.abrupt('return', true);

      case 14:
        context$1$0.prev = 14;
        context$1$0.t1 = context$1$0['catch'](6);
        throw new Error('Unable to stop the background screen recording: ' + context$1$0.t1.message);

      case 17:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[6, 14]]);
}

/**
 * @typedef {Object} StartRecordingOptions
 *
 * @property {?string} remotePath - The path to the remote location, where the captured video should be uploaded.
 *                                  The following protocols are supported: http/https, ftp.
 *                                  Null or empty string value (the default setting) means the content of resulting
 *                                  file should be encoded as Base64 and passed as the endpount response value.
 *                                  An exception will be thrown if the generated media file is too big to
 *                                  fit into the available process memory.
 *                                  This option only has an effect if there is screen recording process in progreess
 *                                  and `forceRestart` parameter is not set to `true`.
 * @property {?string} user - The name of the user for the remote authentication. Only works if `remotePath` is provided.
 * @property {?string} pass - The password for the remote authentication. Only works if `remotePath` is provided.
 * @property {?string} method - The http multipart upload method name. The 'PUT' one is used by default.
 *                              Only works if `remotePath` is provided.
 * @property {?string} videoSize - The format is widthxheight.
 *                  The default value is the device's native display resolution (if supported),
 *                  1280x720 if not. For best results,
 *                  use a size supported by your device's Advanced Video Coding (AVC) encoder.
 *                  For example, "1280x720"
 * @property {?boolean} bugReport - Set it to `true` in order to display additional information on the video overlay,
 *                                  such as a timestamp, that is helpful in videos captured to illustrate bugs.
 *                                  This option is only supported since API level 27 (Android P).
 * @property {?string|number} timeLimit - The maximum recording time, in seconds. The default value is 180 (3 minutes).
 *                                        The maximum value is 1800 (30 minutes). If the passed value is greater than 180 then
 *                                        the algorithm will try to schedule multiple screen recording chunks and merge the
 *                                        resulting videos into a single media file using `ffmpeg` utility.
 *                                        If the utility is not available in PATH then the most recent screen recording chunk is
 *                                        going to be returned.
 * @property {?string|number} bitRate - The video bit rate for the video, in megabits per second.
 *                The default value is 4. You can increase the bit rate to improve video quality,
 *                but doing so results in larger movie files.
 * @property {?boolean} forceRestart - Whether to try to catch and upload/return the currently running screen recording
 *                                     (`false`, the default setting) or ignore the result of it and start a new recording
 *                                     immediately (`true`).
 */

/**
 * Record the display of a real devices running Android 4.4 (API level 19) and higher.
 * Emulators are supported since API level 27 (Android P).
 * It records screen activity to an MPEG-4 file. Audio is not recorded with the video file.
 * If screen recording has been already started then the command will stop it forcefully and start a new one.
 * The previously recorded video file will be deleted.
 *
 * @param {?StartRecordingOptions} options - The available options.
 * @returns {string} Base64-encoded content of the recorded media file if
 *                   any screen recording is currently running or an empty string.
 * @throws {Error} If screen recording has failed to start or is not supported on the device under test.
 */
commands.startRecordingScreen = function callee$0$0() {
  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

  var result, videoSize, _options$timeLimit, timeLimit, bugReport, bitRate, forceRestart, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, record, timeout;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(verifyScreenRecordIsSupported(this.adb, this.isEmulator()));

      case 2:
        result = '';
        videoSize = options.videoSize;
        _options$timeLimit = options.timeLimit;
        timeLimit = _options$timeLimit === undefined ? DEFAULT_RECORDING_TIME_SEC : _options$timeLimit;
        bugReport = options.bugReport;
        bitRate = options.bitRate;
        forceRestart = options.forceRestart;

        if (forceRestart) {
          context$1$0.next = 13;
          break;
        }

        context$1$0.next = 12;
        return _regeneratorRuntime.awrap(this.stopRecordingScreen(options));

      case 12:
        result = context$1$0.sent;

      case 13:
        context$1$0.next = 15;
        return _regeneratorRuntime.awrap(terminateBackgroundScreenRecording(this.adb, true));

      case 15:
        if (!context$1$0.sent) {
          context$1$0.next = 17;
          break;
        }

        _logger2['default'].warn('There were some ' + SCREENRECORD_BINARY + ' process leftovers running ' + 'in the background. Make sure you stop screen recording each time after it is started, ' + 'otherwise the recorded media might quickly exceed all the free space on the device under test.');

      case 17:
        if (_lodash2['default'].isEmpty(this._screenRecordingProperties)) {
          context$1$0.next = 45;
          break;
        }

        _iteratorNormalCompletion = true;
        _didIteratorError = false;
        _iteratorError = undefined;
        context$1$0.prev = 21;
        _iterator = _getIterator(this._screenRecordingProperties.records || []);

      case 23:
        if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
          context$1$0.next = 30;
          break;
        }

        record = _step.value;
        context$1$0.next = 27;
        return _regeneratorRuntime.awrap(this.adb.rimraf(record));

      case 27:
        _iteratorNormalCompletion = true;
        context$1$0.next = 23;
        break;

      case 30:
        context$1$0.next = 36;
        break;

      case 32:
        context$1$0.prev = 32;
        context$1$0.t0 = context$1$0['catch'](21);
        _didIteratorError = true;
        _iteratorError = context$1$0.t0;

      case 36:
        context$1$0.prev = 36;
        context$1$0.prev = 37;

        if (!_iteratorNormalCompletion && _iterator['return']) {
          _iterator['return']();
        }

      case 39:
        context$1$0.prev = 39;

        if (!_didIteratorError) {
          context$1$0.next = 42;
          break;
        }

        throw _iteratorError;

      case 42:
        return context$1$0.finish(39);

      case 43:
        return context$1$0.finish(36);

      case 44:
        this._screenRecordingProperties = null;

      case 45:
        timeout = parseFloat(timeLimit);

        if (!(isNaN(timeout) || timeout > MAX_TIME_SEC || timeout <= 0)) {
          context$1$0.next = 48;
          break;
        }

        throw new Error('The timeLimit value must be in range [1, ' + MAX_TIME_SEC + '] seconds. ' + ('The value of \'' + timeLimit + '\' has been passed instead.'));

      case 48:

        this._screenRecordingProperties = {
          startTimestamp: process.hrtime(),
          videoSize: videoSize,
          timeLimit: timeLimit,
          currentTimeLimit: timeLimit,
          bitRate: bitRate,
          bugReport: bugReport,
          records: [],
          recordingProcess: null,
          stopped: false
        };
        context$1$0.next = 51;
        return _regeneratorRuntime.awrap(scheduleScreenRecord(this.adb, this._screenRecordingProperties));

      case 51:
        return context$1$0.abrupt('return', result);

      case 52:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[21, 32, 36, 44], [37,, 39, 43]]);
};

/**
 * @typedef {Object} StopRecordingOptions
 *
 * @property {?string} remotePath - The path to the remote location, where the resulting video should be uploaded.
 *                                  The following protocols are supported: http/https, ftp.
 *                                  Null or empty string value (the default setting) means the content of resulting
 *                                  file should be encoded as Base64 and passed as the endpount response value.
 *                                  An exception will be thrown if the generated media file is too big to
 *                                  fit into the available process memory.
 * @property {?string} user - The name of the user for the remote authentication.
 * @property {?string} pass - The password for the remote authentication.
 * @property {?string} method - The http multipart upload method name. The 'PUT' one is used by default.
 */

/**
 * Stop recording the screen.
 * If no screen recording has been started before then the method returns an empty string.
 *
 * @param {?StopRecordingOptions} options - The available options.
 * @returns {string} Base64-encoded content of the recorded media file if 'remotePath'
 *                   parameter is falsy or an empty string.
 * @throws {Error} If there was an error while getting the name of a media file
 *                 or the file content cannot be uploaded to the remote location
 *                 or screen recording is not supported on the device under test.
 */
commands.stopRecordingScreen = function callee$0$0() {
  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

  var tmpRoot, localRecords, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, pathOnDevice, resultFilePath, remotePath, user, pass, method;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(verifyScreenRecordIsSupported(this.adb, this.isEmulator()));

      case 2:

        if (!_lodash2['default'].isEmpty(this._screenRecordingProperties)) {
          this._screenRecordingProperties.stopped = true;
        }

        context$1$0.prev = 3;
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(terminateBackgroundScreenRecording(this.adb, false));

      case 6:
        context$1$0.next = 12;
        break;

      case 8:
        context$1$0.prev = 8;
        context$1$0.t0 = context$1$0['catch'](3);

        _logger2['default'].warn(context$1$0.t0.message);
        if (!_lodash2['default'].isEmpty(this._screenRecordingProperties)) {
          _logger2['default'].warn('The resulting video might be corrupted');
        }

      case 12:
        if (!_lodash2['default'].isEmpty(this._screenRecordingProperties)) {
          context$1$0.next = 15;
          break;
        }

        _logger2['default'].info('Screen recording has not been previously started by Appium. There is nothing to stop');
        return context$1$0.abrupt('return', '');

      case 15:
        if (!(this._screenRecordingProperties.recordingProcess && this._screenRecordingProperties.recordingProcess.isRunning)) {
          context$1$0.next = 25;
          break;
        }

        context$1$0.prev = 16;
        context$1$0.next = 19;
        return _regeneratorRuntime.awrap(this._screenRecordingProperties.recordingProcess.stop('SIGINT', PROCESS_SHUTDOWN_TIMEOUT));

      case 19:
        context$1$0.next = 24;
        break;

      case 21:
        context$1$0.prev = 21;
        context$1$0.t1 = context$1$0['catch'](16);

        _logger2['default'].errorAndThrow('Unable to stop screen recording within ' + PROCESS_SHUTDOWN_TIMEOUT + 'ms');

      case 24:
        this._screenRecordingProperties.recordingProcess = null;

      case 25:

        if (_lodash2['default'].isEmpty(this._screenRecordingProperties.records)) {
          _logger2['default'].errorAndThrow('No screen recordings have been stored on the device so far. ' + ('Are you sure the ' + SCREENRECORD_BINARY + ' utility works as expected?'));
        }

        context$1$0.next = 28;
        return _regeneratorRuntime.awrap(_appiumSupport.tempDir.openDir());

      case 28:
        tmpRoot = context$1$0.sent;
        context$1$0.prev = 29;
        localRecords = [];
        _iteratorNormalCompletion2 = true;
        _didIteratorError2 = false;
        _iteratorError2 = undefined;
        context$1$0.prev = 34;
        _iterator2 = _getIterator(this._screenRecordingProperties.records);

      case 36:
        if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
          context$1$0.next = 46;
          break;
        }

        pathOnDevice = _step2.value;

        localRecords.push(_path2['default'].resolve(tmpRoot, _path2['default'].posix.basename(pathOnDevice)));
        context$1$0.next = 41;
        return _regeneratorRuntime.awrap(this.adb.pull(pathOnDevice, _lodash2['default'].last(localRecords)));

      case 41:
        context$1$0.next = 43;
        return _regeneratorRuntime.awrap(this.adb.rimraf(pathOnDevice));

      case 43:
        _iteratorNormalCompletion2 = true;
        context$1$0.next = 36;
        break;

      case 46:
        context$1$0.next = 52;
        break;

      case 48:
        context$1$0.prev = 48;
        context$1$0.t2 = context$1$0['catch'](34);
        _didIteratorError2 = true;
        _iteratorError2 = context$1$0.t2;

      case 52:
        context$1$0.prev = 52;
        context$1$0.prev = 53;

        if (!_iteratorNormalCompletion2 && _iterator2['return']) {
          _iterator2['return']();
        }

      case 55:
        context$1$0.prev = 55;

        if (!_didIteratorError2) {
          context$1$0.next = 58;
          break;
        }

        throw _iteratorError2;

      case 58:
        return context$1$0.finish(55);

      case 59:
        return context$1$0.finish(52);

      case 60:
        resultFilePath = _lodash2['default'].last(localRecords);

        if (!(localRecords.length > 1)) {
          context$1$0.next = 72;
          break;
        }

        _logger2['default'].info('Got ' + localRecords.length + ' screen recordings. Trying to merge them');
        context$1$0.prev = 63;
        context$1$0.next = 66;
        return _regeneratorRuntime.awrap(mergeScreenRecords(localRecords));

      case 66:
        resultFilePath = context$1$0.sent;
        context$1$0.next = 72;
        break;

      case 69:
        context$1$0.prev = 69;
        context$1$0.t3 = context$1$0['catch'](63);

        _logger2['default'].warn('Cannot merge the recorded files. The most recent screen recording is going to be returned as the result. ' + ('Original error: ' + context$1$0.t3.message));

      case 72:
        remotePath = options.remotePath;
        user = options.user;
        pass = options.pass;
        method = options.method;
        context$1$0.next = 78;
        return _regeneratorRuntime.awrap(uploadRecordedMedia(this.adb, resultFilePath, remotePath, { user: user, pass: pass, method: method }));

      case 78:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 79:
        context$1$0.prev = 79;
        context$1$0.next = 82;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.rimraf(tmpRoot));

      case 82:
        this._screenRecordingProperties = null;
        return context$1$0.finish(79);

      case 84:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[3, 8], [16, 21], [29,, 79, 84], [34, 48, 52, 60], [53,, 55, 59], [63, 69]]);
};

_Object$assign(extensions, commands);
exports.commands = commands;
exports['default'] = extensions;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9jb21tYW5kcy9yZWNvcmRzY3JlZW4uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztzQkFBYyxRQUFROzs7O21CQUNOLElBQUk7Ozs7bUJBQ0osS0FBSzs7Ozt3QkFDWSxVQUFVOzs2QkFDSSxnQkFBZ0I7O3NCQUMvQyxXQUFXOzs7OzRCQUNOLGNBQWM7O29CQUNsQixNQUFNOzs7O2tCQUNSLElBQUk7Ozs7QUFHbkIsSUFBSSxRQUFRLEdBQUcsRUFBRTtJQUFFLFVBQVUsR0FBRyxFQUFFLENBQUM7O0FBRW5DLElBQU0sV0FBVyxHQUFHLEdBQUcsQ0FBQztBQUN4QixJQUFNLGFBQWEsR0FBRyxJQUFJLENBQUM7QUFDM0IsSUFBTSxzQkFBc0IsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0FBQ3RDLElBQU0sWUFBWSxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUM7QUFDN0IsSUFBTSwwQkFBMEIsR0FBRyxzQkFBc0IsQ0FBQztBQUMxRCxJQUFNLHdCQUF3QixHQUFHLEVBQUUsR0FBRyxJQUFJLENBQUM7QUFDM0MsSUFBTSxtQkFBbUIsR0FBRyxjQUFjLENBQUM7QUFDM0MsSUFBTSxXQUFXLEdBQUcsTUFBTSxDQUFDO0FBQzNCLElBQU0sc0JBQXNCLEdBQUcsRUFBRSxDQUFDO0FBQ2xDLElBQU0sYUFBYSxlQUFZLHNCQUFPLFNBQVMsRUFBRSxHQUFHLE1BQU0sR0FBRyxFQUFFLENBQUEsQUFBRSxDQUFDOztBQUVsRSxTQUFlLG1CQUFtQixDQUFFLEdBQUcsRUFBRSxTQUFTO01BQUUsVUFBVSx5REFBRyxJQUFJO01BQUUsYUFBYSx5REFBRyxFQUFFOztZQUNoRixJQUFJLEVBR0gsY0FBYyxFQVVoQixTQUFTLEVBQ1gsT0FBTyxFQUNKLElBQUksRUFBRSxJQUFJLEVBQUUsTUFBTTs7Ozs7O3lDQWZKLGtCQUFHLElBQUksQ0FBQyxTQUFTLENBQUM7Ozs7QUFBaEMsWUFBSSxRQUFKLElBQUk7O0FBQ1gsNEJBQUksS0FBSyxvREFB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QyxDQUFDOztBQUdGLGVBQWMsVUFBVSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1FBQzNCLFFBQVEsR0FBUixRQUFRO3FCQUNGLFVBQVUiLCJmaWxlIjoibGliL2NvbW1hbmRzL3JlY29yZHNjcmVlbi5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgX2ZzIGZyb20gJ2ZzJztcbmltcG9ydCB1cmwgZnJvbSAndXJsJztcbmltcG9ydCB7IHdhaXRGb3JDb25kaXRpb24gfSBmcm9tICdhc3luY2JveCc7XG5pbXBvcnQgeyB1dGlsLCBmcywgbmV0LCB0ZW1wRGlyLCBzeXN0ZW0gfSBmcm9tICdhcHBpdW0tc3VwcG9ydCc7XG5pbXBvcnQgbG9nIGZyb20gJy4uL2xvZ2dlcic7XG5pbXBvcnQgeyBleGVjIH0gZnJvbSAndGVlbl9wcm9jZXNzJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHY4IGZyb20gJ3Y4JztcblxuXG5sZXQgY29tbWFuZHMgPSB7fSwgZXh0ZW5zaW9ucyA9IHt9O1xuXG5jb25zdCBSRVRSWV9QQVVTRSA9IDMwMDtcbmNvbnN0IFJFVFJZX1RJTUVPVVQgPSA1MDAwO1xuY29uc3QgTUFYX1JFQ09SRElOR19USU1FX1NFQyA9IDYwICogMztcbmNvbnN0IE1BWF9USU1FX1NFQyA9IDYwICogMzA7XG5jb25zdCBERUZBVUxUX1JFQ09SRElOR19USU1FX1NFQyA9IE1BWF9SRUNPUkRJTkdfVElNRV9TRUM7XG5jb25zdCBQUk9DRVNTX1NIVVRET1dOX1RJTUVPVVQgPSAxMCAqIDEwMDA7XG5jb25zdCBTQ1JFRU5SRUNPUkRfQklOQVJZID0gJ3NjcmVlbnJlY29yZCc7XG5jb25zdCBERUZBVUxUX0VYVCA9ICcubXA0JztcbmNvbnN0IE1JTl9FTVVMQVRPUl9BUElfTEVWRUwgPSAyNztcbmNvbnN0IEZGTVBFR19CSU5BUlkgPSBgZmZtcGVnJHtzeXN0ZW0uaXNXaW5kb3dzKCkgPyAnLmV4ZScgOiAnJ31gO1xuXG5hc3luYyBmdW5jdGlvbiB1cGxvYWRSZWNvcmRlZE1lZGlhIChhZGIsIGxvY2FsRmlsZSwgcmVtb3RlUGF0aCA9IG51bGwsIHVwbG9hZE9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7c2l6ZX0gPSBhd2FpdCBmcy5zdGF0KGxvY2FsRmlsZSk7XG4gIGxvZy5kZWJ1ZyhgVGhlIHNpemUgb2YgdGhlIHJlc3VsdGluZyBzY3JlZW4gcmVjb3JkaW5nIGlzICR7dXRpbC50b1JlYWRhYmxlU2l6ZVN0cmluZyhzaXplKX1gKTtcbiAgaWYgKF8uaXNFbXB0eShyZW1vdGVQYXRoKSkge1xuICAgIGNvbnN0IG1heE1lbW9yeUxpbWl0ID0gdjguZ2V0SGVhcFN0YXRpc3RpY3MoKS50b3RhbF9hdmFpbGFibGVfc2l6ZSAvIDI7XG4gICAgaWYgKHNpemUgPj0gbWF4TWVtb3J5TGltaXQpIHtcbiAgICAgIGxvZy5pbmZvKGBUaGUgZmlsZSBtaWdodCBiZSB0b28gbGFyZ2UgdG8gZml0IGludG8gdGhlIHByb2Nlc3MgbWVtb3J5IGAgK1xuICAgICAgICBgKCR7dXRpbC50b1JlYWRhYmxlU2l6ZVN0cmluZyhzaXplKX0gPj0gJHt1dGlsLnRvUmVhZGFibGVTaXplU3RyaW5nKG1heE1lbW9yeUxpbWl0KX0pLiBgICtcbiAgICAgICAgYFByb3ZpZGUgYSBsaW5rIHRvIGEgcmVtb3RlIHdyaXRhYmxlIGxvY2F0aW9uIGZvciB2aWRlbyB1cGxvYWQgYCArXG4gICAgICAgIGAoaHR0cChzKSBhbmQgZnRwIHByb3RvY29scyBhcmUgc3VwcG9ydGVkKSBpZiB5b3UgZXhwZXJpZW5jZSBPdXQgT2YgTWVtb3J5IGVycm9yc2ApO1xuICAgIH1cbiAgICByZXR1cm4gKGF3YWl0IGZzLnJlYWRGaWxlKGxvY2FsRmlsZSkpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgfVxuXG4gIGNvbnN0IHJlbW90ZVVybCA9IHVybC5wYXJzZShyZW1vdGVQYXRoKTtcbiAgbGV0IG9wdGlvbnMgPSB7fTtcbiAgY29uc3Qge3VzZXIsIHBhc3MsIG1ldGhvZH0gPSB1cGxvYWRPcHRpb25zO1xuICBpZiAocmVtb3RlVXJsLnByb3RvY29sLnN0YXJ0c1dpdGgoJ2h0dHAnKSkge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICB1cmw6IHJlbW90ZVVybC5ocmVmLFxuICAgICAgbWV0aG9kOiBtZXRob2QgfHwgJ1BVVCcsXG4gICAgICBtdWx0aXBhcnQ6IFt7IGJvZHk6IF9mcy5jcmVhdGVSZWFkU3RyZWFtKGxvY2FsRmlsZSkgfV0sXG4gICAgfTtcbiAgICBpZiAodXNlciAmJiBwYXNzKSB7XG4gICAgICBvcHRpb25zLmF1dGggPSB7dXNlciwgcGFzc307XG4gICAgfVxuICB9IGVsc2UgaWYgKHJlbW90ZVVybC5wcm90b2NvbC5zdGFydHNXaXRoKCdmdHAnKSkge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBob3N0OiByZW1vdGVVcmwuaG9zdG5hbWUsXG4gICAgICBwb3J0OiByZW1vdGVVcmwucG9ydCB8fCAyMSxcbiAgICB9O1xuICAgIGlmICh1c2VyICYmIHBhc3MpIHtcbiAgICAgIG9wdGlvbnMudXNlciA9IHVzZXI7XG4gICAgICBvcHRpb25zLnBhc3MgPSBwYXNzO1xuICAgIH1cbiAgfVxuICBhd2FpdCBuZXQudXBsb2FkRmlsZShsb2NhbEZpbGUsIHJlbW90ZVBhdGgsIG9wdGlvbnMpO1xuICByZXR1cm4gJyc7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHZlcmlmeVNjcmVlblJlY29yZElzU3VwcG9ydGVkIChhZGIsIGlzRW11bGF0b3IpIHtcbiAgY29uc3QgYXBpTGV2ZWwgPSBhd2FpdCBhZGIuZ2V0QXBpTGV2ZWwoKTtcbiAgaWYgKGlzRW11bGF0b3IgJiYgYXBpTGV2ZWwgPCBNSU5fRU1VTEFUT1JfQVBJX0xFVkVMKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBTY3JlZW4gcmVjb3JkaW5nIGRvZXMgbm90IHdvcmsgb24gZW11bGF0b3JzIHJ1bm5pbmcgQW5kcm9pZCBBUEkgbGV2ZWwgbGVzcyB0aGFuICR7TUlOX0VNVUxBVE9SX0FQSV9MRVZFTH1gKTtcbiAgfVxuICBpZiAoYXBpTGV2ZWwgPCAxOSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgU2NyZWVuIHJlY29yZGluZyBub3QgYXZhaWxhYmxlIG9uIEFQSSBMZXZlbCAke2FwaUxldmVsfS4gTWluaW11bSBBUEkgTGV2ZWwgaXMgMTkuYCk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gc2NoZWR1bGVTY3JlZW5SZWNvcmQgKGFkYiwgcmVjb3JkaW5nUHJvcGVydGllcykge1xuICBpZiAocmVjb3JkaW5nUHJvcGVydGllcy5zdG9wcGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qge1xuICAgIHN0YXJ0VGltZXN0YW1wLFxuICAgIHZpZGVvU2l6ZSxcbiAgICBiaXRSYXRlLFxuICAgIHRpbWVMaW1pdCxcbiAgICBidWdSZXBvcnQsXG4gIH0gPSByZWNvcmRpbmdQcm9wZXJ0aWVzO1xuXG4gIGxldCBjdXJyZW50VGltZUxpbWl0ID0gTUFYX1JFQ09SRElOR19USU1FX1NFQztcbiAgaWYgKHV0aWwuaGFzVmFsdWUocmVjb3JkaW5nUHJvcGVydGllcy5jdXJyZW50VGltZUxpbWl0KSkge1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lTGltaXRJbnQgPSBwYXJzZUludChyZWNvcmRpbmdQcm9wZXJ0aWVzLmN1cnJlbnRUaW1lTGltaXQsIDEwKTtcbiAgICBpZiAoIWlzTmFOKGN1cnJlbnRUaW1lTGltaXRJbnQpICYmIGN1cnJlbnRUaW1lTGltaXRJbnQgPCBNQVhfUkVDT1JESU5HX1RJTUVfU0VDKSB7XG4gICAgICBjdXJyZW50VGltZUxpbWl0ID0gY3VycmVudFRpbWVMaW1pdEludDtcbiAgICB9XG4gIH1cbiAgY29uc3QgcGF0aE9uRGV2aWNlID0gYC9zZGNhcmQvJHtNYXRoLmZsb29yKG5ldyBEYXRlKCkpfSR7REVGQVVMVF9FWFR9YDtcbiAgY29uc3QgcmVjb3JkaW5nUHJvYyA9IGFkYi5zY3JlZW5yZWNvcmQocGF0aE9uRGV2aWNlLCB7XG4gICAgdmlkZW9TaXplLFxuICAgIGJpdFJhdGUsXG4gICAgdGltZUxpbWl0OiBjdXJyZW50VGltZUxpbWl0LFxuICAgIGJ1Z1JlcG9ydCxcbiAgfSk7XG5cbiAgcmVjb3JkaW5nUHJvYy5vbignZW5kJywgKCkgPT4ge1xuICAgIGlmIChyZWNvcmRpbmdQcm9wZXJ0aWVzLnN0b3BwZWQgfHwgIXV0aWwuaGFzVmFsdWUodGltZUxpbWl0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50RHVyYXRpb24gPSBwcm9jZXNzLmhydGltZShzdGFydFRpbWVzdGFtcClbMF07XG4gICAgbG9nLmRlYnVnKGBUaGUgb3ZlcmFsbCBzY3JlZW4gcmVjb3JkaW5nIGR1cmF0aW9uIGlzICR7Y3VycmVudER1cmF0aW9ufXMgc28gZmFyYCk7XG4gICAgY29uc3QgdGltZUxpbWl0SW50ID0gcGFyc2VJbnQodGltZUxpbWl0LCAxMCk7XG4gICAgaWYgKGlzTmFOKHRpbWVMaW1pdEludCkgfHwgY3VycmVudER1cmF0aW9uID49IHRpbWVMaW1pdEludCkge1xuICAgICAgbG9nLmRlYnVnKCdUaGVyZSBpcyBubyBuZWVkIHRvIHN0YXJ0IHRoZSBuZXh0IHJlY29yZGluZyBjaHVuaycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlY29yZGluZ1Byb3BlcnRpZXMuY3VycmVudFRpbWVMaW1pdCA9IHRpbWVMaW1pdEludCAtIGN1cnJlbnREdXJhdGlvbjtcbiAgICBjb25zdCBjaHVua0R1cmF0aW9uID0gcmVjb3JkaW5nUHJvcGVydGllcy5jdXJyZW50VGltZUxpbWl0IDwgTUFYX1JFQ09SRElOR19USU1FX1NFQ1xuICAgICAgPyByZWNvcmRpbmdQcm9wZXJ0aWVzLmN1cnJlbnRUaW1lTGltaXRcbiAgICAgIDogTUFYX1JFQ09SRElOR19USU1FX1NFQztcbiAgICBsb2cuZGVidWcoYFN0YXJ0aW5nIHRoZSBuZXh0ICR7Y2h1bmtEdXJhdGlvbn1zLWNodW5rIGAgK1xuICAgICAgYG9mIHNjcmVlbiByZWNvcmRpbmcgaW4gb3JkZXIgdG8gYWNoaWV2ZSAke3RpbWVMaW1pdEludH1zIHRvdGFsIGR1cmF0aW9uYCk7XG4gICAgc2NoZWR1bGVTY3JlZW5SZWNvcmQoYWRiLCByZWNvcmRpbmdQcm9wZXJ0aWVzKVxuICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgIGxvZy5lcnJvcihlLnN0YWNrKTtcbiAgICAgICAgcmVjb3JkaW5nUHJvcGVydGllcy5zdG9wcGVkID0gdHJ1ZTtcbiAgICAgIH0pO1xuICB9KTtcblxuICBhd2FpdCByZWNvcmRpbmdQcm9jLnN0YXJ0KDApO1xuICB0cnkge1xuICAgIGF3YWl0IHdhaXRGb3JDb25kaXRpb24oYXN5bmMgKCkgPT4gYXdhaXQgYWRiLmZpbGVFeGlzdHMocGF0aE9uRGV2aWNlKSxcbiAgICAgIHt3YWl0TXM6IFJFVFJZX1RJTUVPVVQsIGludGVydmFsTXM6IFJFVFJZX1BBVVNFfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBleHBlY3RlZCBzY3JlZW4gcmVjb3JkIGZpbGUgJyR7cGF0aE9uRGV2aWNlfScgZG9lcyBub3QgZXhpc3QgYWZ0ZXIgJHtSRVRSWV9USU1FT1VUfW1zYCk7XG4gIH1cblxuICByZWNvcmRpbmdQcm9wZXJ0aWVzLnJlY29yZHMucHVzaChwYXRoT25EZXZpY2UpO1xuICByZWNvcmRpbmdQcm9wZXJ0aWVzLnJlY29yZGluZ1Byb2Nlc3MgPSByZWNvcmRpbmdQcm9jO1xufVxuXG5hc3luYyBmdW5jdGlvbiBtZXJnZVNjcmVlblJlY29yZHMgKG1lZGlhRmlsZXMpIHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBmcy53aGljaChGRk1QRUdfQklOQVJZKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHtGRk1QRUdfQklOQVJZfSB1dGlsaXR5IGlzIG5vdCBhdmFpbGFibGUgaW4gUEFUSC4gUGxlYXNlIGluc3RhbGwgaXQgZnJvbSBodHRwczovL3d3dy5mZm1wZWcub3JnL2ApO1xuICB9XG4gIGNvbnN0IGNvbmZpZ0NvbnRlbnQgPSBtZWRpYUZpbGVzXG4gICAgLm1hcCgoeCkgPT4gYGZpbGUgJyR7eH0nYClcbiAgICAuam9pbignXFxuJyk7XG4gIGNvbnN0IGNvbmZpZ0ZpbGUgPSBwYXRoLnJlc29sdmUocGF0aC5kaXJuYW1lKG1lZGlhRmlsZXNbMF0pLCAnY29uZmlnLnR4dCcpO1xuICBhd2FpdCBmcy53cml0ZUZpbGUoY29uZmlnRmlsZSwgY29uZmlnQ29udGVudCwgJ3V0ZjgnKTtcbiAgbG9nLmRlYnVnKGBHZW5lcmF0ZWQgZmZtcGVnIG1lcmdpbmcgY29uZmlnICcke2NvbmZpZ0ZpbGV9JyB3aXRoIGl0ZW1zOlxcbiR7Y29uZmlnQ29udGVudH1gKTtcbiAgY29uc3QgcmVzdWx0ID0gcGF0aC5yZXNvbHZlKHBhdGguZGlybmFtZShtZWRpYUZpbGVzWzBdKSwgYG1lcmdlXyR7TWF0aC5mbG9vcihuZXcgRGF0ZSgpKX0ke0RFRkFVTFRfRVhUfWApO1xuICBjb25zdCBhcmdzID0gWyctc2FmZScsICcwJywgJy1mJywgJ2NvbmNhdCcsICctaScsIGNvbmZpZ0ZpbGUsICctYycsICdjb3B5JywgcmVzdWx0XTtcbiAgbG9nLmluZm8oYEluaXRpYXRpbmcgc2NyZWVuIHJlY29yZHMgbWVyZ2luZyB1c2luZyB0aGUgY29tbWFuZCAnJHtGRk1QRUdfQklOQVJZfSAke2FyZ3Muam9pbignICcpfSdgKTtcbiAgYXdhaXQgZXhlYyhGRk1QRUdfQklOQVJZLCBhcmdzKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuYXN5bmMgZnVuY3Rpb24gdGVybWluYXRlQmFja2dyb3VuZFNjcmVlblJlY29yZGluZyAoYWRiLCBmb3JjZSA9IHRydWUpIHtcbiAgY29uc3QgcGlkcyA9IChhd2FpdCBhZGIuZ2V0UElEc0J5TmFtZShTQ1JFRU5SRUNPUkRfQklOQVJZKSlcbiAgICAubWFwKChwKSA9PiBgJHtwfWApO1xuICBpZiAoXy5pc0VtcHR5KHBpZHMpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBhd2FpdCBhZGIuc2hlbGwoWydraWxsJywgZm9yY2UgPyAnLTE1JyA6ICctMicsIC4uLnBpZHNdKTtcbiAgICBhd2FpdCB3YWl0Rm9yQ29uZGl0aW9uKGFzeW5jICgpID0+IF8uaXNFbXB0eShhd2FpdCBhZGIuZ2V0UElEc0J5TmFtZShTQ1JFRU5SRUNPUkRfQklOQVJZKSksIHtcbiAgICAgIHdhaXRNczogUFJPQ0VTU19TSFVURE9XTl9USU1FT1VULFxuICAgICAgaW50ZXJ2YWxNczogNTAwLFxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBzdG9wIHRoZSBiYWNrZ3JvdW5kIHNjcmVlbiByZWNvcmRpbmc6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gIH1cbn1cblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFN0YXJ0UmVjb3JkaW5nT3B0aW9uc1xuICpcbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gcmVtb3RlUGF0aCAtIFRoZSBwYXRoIHRvIHRoZSByZW1vdGUgbG9jYXRpb24sIHdoZXJlIHRoZSBjYXB0dXJlZCB2aWRlbyBzaG91bGQgYmUgdXBsb2FkZWQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgZm9sbG93aW5nIHByb3RvY29scyBhcmUgc3VwcG9ydGVkOiBodHRwL2h0dHBzLCBmdHAuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOdWxsIG9yIGVtcHR5IHN0cmluZyB2YWx1ZSAodGhlIGRlZmF1bHQgc2V0dGluZykgbWVhbnMgdGhlIGNvbnRlbnQgb2YgcmVzdWx0aW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlIHNob3VsZCBiZSBlbmNvZGVkIGFzIEJhc2U2NCBhbmQgcGFzc2VkIGFzIHRoZSBlbmRwb3VudCByZXNwb25zZSB2YWx1ZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93biBpZiB0aGUgZ2VuZXJhdGVkIG1lZGlhIGZpbGUgaXMgdG9vIGJpZyB0b1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZml0IGludG8gdGhlIGF2YWlsYWJsZSBwcm9jZXNzIG1lbW9yeS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoaXMgb3B0aW9uIG9ubHkgaGFzIGFuIGVmZmVjdCBpZiB0aGVyZSBpcyBzY3JlZW4gcmVjb3JkaW5nIHByb2Nlc3MgaW4gcHJvZ3JlZXNzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgYGZvcmNlUmVzdGFydGAgcGFyYW1ldGVyIGlzIG5vdCBzZXQgdG8gYHRydWVgLlxuICogQHByb3BlcnR5IHs/c3RyaW5nfSB1c2VyIC0gVGhlIG5hbWUgb2YgdGhlIHVzZXIgZm9yIHRoZSByZW1vdGUgYXV0aGVudGljYXRpb24uIE9ubHkgd29ya3MgaWYgYHJlbW90ZVBhdGhgIGlzIHByb3ZpZGVkLlxuICogQHByb3BlcnR5IHs/c3RyaW5nfSBwYXNzIC0gVGhlIHBhc3N3b3JkIGZvciB0aGUgcmVtb3RlIGF1dGhlbnRpY2F0aW9uLiBPbmx5IHdvcmtzIGlmIGByZW1vdGVQYXRoYCBpcyBwcm92aWRlZC5cbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gbWV0aG9kIC0gVGhlIGh0dHAgbXVsdGlwYXJ0IHVwbG9hZCBtZXRob2QgbmFtZS4gVGhlICdQVVQnIG9uZSBpcyB1c2VkIGJ5IGRlZmF1bHQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9ubHkgd29ya3MgaWYgYHJlbW90ZVBhdGhgIGlzIHByb3ZpZGVkLlxuICogQHByb3BlcnR5IHs/c3RyaW5nfSB2aWRlb1NpemUgLSBUaGUgZm9ybWF0IGlzIHdpZHRoeGhlaWdodC5cbiAqICAgICAgICAgICAgICAgICAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdGhlIGRldmljZSdzIG5hdGl2ZSBkaXNwbGF5IHJlc29sdXRpb24gKGlmIHN1cHBvcnRlZCksXG4gKiAgICAgICAgICAgICAgICAgIDEyODB4NzIwIGlmIG5vdC4gRm9yIGJlc3QgcmVzdWx0cyxcbiAqICAgICAgICAgICAgICAgICAgdXNlIGEgc2l6ZSBzdXBwb3J0ZWQgYnkgeW91ciBkZXZpY2UncyBBZHZhbmNlZCBWaWRlbyBDb2RpbmcgKEFWQykgZW5jb2Rlci5cbiAqICAgICAgICAgICAgICAgICAgRm9yIGV4YW1wbGUsIFwiMTI4MHg3MjBcIlxuICogQHByb3BlcnR5IHs/Ym9vbGVhbn0gYnVnUmVwb3J0IC0gU2V0IGl0IHRvIGB0cnVlYCBpbiBvcmRlciB0byBkaXNwbGF5IGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gb24gdGhlIHZpZGVvIG92ZXJsYXksXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNoIGFzIGEgdGltZXN0YW1wLCB0aGF0IGlzIGhlbHBmdWwgaW4gdmlkZW9zIGNhcHR1cmVkIHRvIGlsbHVzdHJhdGUgYnVncy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoaXMgb3B0aW9uIGlzIG9ubHkgc3VwcG9ydGVkIHNpbmNlIEFQSSBsZXZlbCAyNyAoQW5kcm9pZCBQKS5cbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ3xudW1iZXJ9IHRpbWVMaW1pdCAtIFRoZSBtYXhpbXVtIHJlY29yZGluZyB0aW1lLCBpbiBzZWNvbmRzLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyAxODAgKDMgbWludXRlcykuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgbWF4aW11bSB2YWx1ZSBpcyAxODAwICgzMCBtaW51dGVzKS4gSWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gMTgwIHRoZW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBhbGdvcml0aG0gd2lsbCB0cnkgdG8gc2NoZWR1bGUgbXVsdGlwbGUgc2NyZWVuIHJlY29yZGluZyBjaHVua3MgYW5kIG1lcmdlIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0aW5nIHZpZGVvcyBpbnRvIGEgc2luZ2xlIG1lZGlhIGZpbGUgdXNpbmcgYGZmbXBlZ2AgdXRpbGl0eS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIHRoZSB1dGlsaXR5IGlzIG5vdCBhdmFpbGFibGUgaW4gUEFUSCB0aGVuIHRoZSBtb3N0IHJlY2VudCBzY3JlZW4gcmVjb3JkaW5nIGNodW5rIGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnb2luZyB0byBiZSByZXR1cm5lZC5cbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ3xudW1iZXJ9IGJpdFJhdGUgLSBUaGUgdmlkZW8gYml0IHJhdGUgZm9yIHRoZSB2aWRlbywgaW4gbWVnYWJpdHMgcGVyIHNlY29uZC5cbiAqICAgICAgICAgICAgICAgIFRoZSBkZWZhdWx0IHZhbHVlIGlzIDQuIFlvdSBjYW4gaW5jcmVhc2UgdGhlIGJpdCByYXRlIHRvIGltcHJvdmUgdmlkZW8gcXVhbGl0eSxcbiAqICAgICAgICAgICAgICAgIGJ1dCBkb2luZyBzbyByZXN1bHRzIGluIGxhcmdlciBtb3ZpZSBmaWxlcy5cbiAqIEBwcm9wZXJ0eSB7P2Jvb2xlYW59IGZvcmNlUmVzdGFydCAtIFdoZXRoZXIgdG8gdHJ5IHRvIGNhdGNoIGFuZCB1cGxvYWQvcmV0dXJuIHRoZSBjdXJyZW50bHkgcnVubmluZyBzY3JlZW4gcmVjb3JkaW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYGZhbHNlYCwgdGhlIGRlZmF1bHQgc2V0dGluZykgb3IgaWdub3JlIHRoZSByZXN1bHQgb2YgaXQgYW5kIHN0YXJ0IGEgbmV3IHJlY29yZGluZ1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1tZWRpYXRlbHkgKGB0cnVlYCkuXG4gKi9cblxuLyoqXG4gKiBSZWNvcmQgdGhlIGRpc3BsYXkgb2YgYSByZWFsIGRldmljZXMgcnVubmluZyBBbmRyb2lkIDQuNCAoQVBJIGxldmVsIDE5KSBhbmQgaGlnaGVyLlxuICogRW11bGF0b3JzIGFyZSBzdXBwb3J0ZWQgc2luY2UgQVBJIGxldmVsIDI3IChBbmRyb2lkIFApLlxuICogSXQgcmVjb3JkcyBzY3JlZW4gYWN0aXZpdHkgdG8gYW4gTVBFRy00IGZpbGUuIEF1ZGlvIGlzIG5vdCByZWNvcmRlZCB3aXRoIHRoZSB2aWRlbyBmaWxlLlxuICogSWYgc2NyZWVuIHJlY29yZGluZyBoYXMgYmVlbiBhbHJlYWR5IHN0YXJ0ZWQgdGhlbiB0aGUgY29tbWFuZCB3aWxsIHN0b3AgaXQgZm9yY2VmdWxseSBhbmQgc3RhcnQgYSBuZXcgb25lLlxuICogVGhlIHByZXZpb3VzbHkgcmVjb3JkZWQgdmlkZW8gZmlsZSB3aWxsIGJlIGRlbGV0ZWQuXG4gKlxuICogQHBhcmFtIHs/U3RhcnRSZWNvcmRpbmdPcHRpb25zfSBvcHRpb25zIC0gVGhlIGF2YWlsYWJsZSBvcHRpb25zLlxuICogQHJldHVybnMge3N0cmluZ30gQmFzZTY0LWVuY29kZWQgY29udGVudCBvZiB0aGUgcmVjb3JkZWQgbWVkaWEgZmlsZSBpZlxuICogICAgICAgICAgICAgICAgICAgYW55IHNjcmVlbiByZWNvcmRpbmcgaXMgY3VycmVudGx5IHJ1bm5pbmcgb3IgYW4gZW1wdHkgc3RyaW5nLlxuICogQHRocm93cyB7RXJyb3J9IElmIHNjcmVlbiByZWNvcmRpbmcgaGFzIGZhaWxlZCB0byBzdGFydCBvciBpcyBub3Qgc3VwcG9ydGVkIG9uIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqL1xuY29tbWFuZHMuc3RhcnRSZWNvcmRpbmdTY3JlZW4gPSBhc3luYyBmdW5jdGlvbiAob3B0aW9ucyA9IHt9KSB7XG4gIGF3YWl0IHZlcmlmeVNjcmVlblJlY29yZElzU3VwcG9ydGVkKHRoaXMuYWRiLCB0aGlzLmlzRW11bGF0b3IoKSk7XG5cbiAgbGV0IHJlc3VsdCA9ICcnO1xuICBjb25zdCB7dmlkZW9TaXplLCB0aW1lTGltaXQ9REVGQVVMVF9SRUNPUkRJTkdfVElNRV9TRUMsIGJ1Z1JlcG9ydCwgYml0UmF0ZSwgZm9yY2VSZXN0YXJ0fSA9IG9wdGlvbnM7XG4gIGlmICghZm9yY2VSZXN0YXJ0KSB7XG4gICAgcmVzdWx0ID0gYXdhaXQgdGhpcy5zdG9wUmVjb3JkaW5nU2NyZWVuKG9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKGF3YWl0IHRlcm1pbmF0ZUJhY2tncm91bmRTY3JlZW5SZWNvcmRpbmcodGhpcy5hZGIsIHRydWUpKSB7XG4gICAgbG9nLndhcm4oYFRoZXJlIHdlcmUgc29tZSAke1NDUkVFTlJFQ09SRF9CSU5BUll9IHByb2Nlc3MgbGVmdG92ZXJzIHJ1bm5pbmcgYCArXG4gICAgICBgaW4gdGhlIGJhY2tncm91bmQuIE1ha2Ugc3VyZSB5b3Ugc3RvcCBzY3JlZW4gcmVjb3JkaW5nIGVhY2ggdGltZSBhZnRlciBpdCBpcyBzdGFydGVkLCBgICtcbiAgICAgIGBvdGhlcndpc2UgdGhlIHJlY29yZGVkIG1lZGlhIG1pZ2h0IHF1aWNrbHkgZXhjZWVkIGFsbCB0aGUgZnJlZSBzcGFjZSBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuYCk7XG4gIH1cblxuICBpZiAoIV8uaXNFbXB0eSh0aGlzLl9zY3JlZW5SZWNvcmRpbmdQcm9wZXJ0aWVzKSkge1xuICAgIGZvciAoY29uc3QgcmVjb3JkIG9mICh0aGlzLl9zY3JlZW5SZWNvcmRpbmdQcm9wZXJ0aWVzLnJlY29yZHMgfHwgW10pKSB7XG4gICAgICBhd2FpdCB0aGlzLmFkYi5yaW1yYWYocmVjb3JkKTtcbiAgICB9XG4gICAgdGhpcy5fc2NyZWVuUmVjb3JkaW5nUHJvcGVydGllcyA9IG51bGw7XG4gIH1cblxuICBjb25zdCB0aW1lb3V0ID0gcGFyc2VGbG9hdCh0aW1lTGltaXQpO1xuICBpZiAoaXNOYU4odGltZW91dCkgfHwgdGltZW91dCA+IE1BWF9USU1FX1NFQyB8fCB0aW1lb3V0IDw9IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSB0aW1lTGltaXQgdmFsdWUgbXVzdCBiZSBpbiByYW5nZSBbMSwgJHtNQVhfVElNRV9TRUN9XSBzZWNvbmRzLiBgICtcbiAgICAgIGBUaGUgdmFsdWUgb2YgJyR7dGltZUxpbWl0fScgaGFzIGJlZW4gcGFzc2VkIGluc3RlYWQuYCk7XG4gIH1cblxuICB0aGlzLl9zY3JlZW5SZWNvcmRpbmdQcm9wZXJ0aWVzID0ge1xuICAgIHN0YXJ0VGltZXN0YW1wOiBwcm9jZXNzLmhydGltZSgpLFxuICAgIHZpZGVvU2l6ZSxcbiAgICB0aW1lTGltaXQsXG4gICAgY3VycmVudFRpbWVMaW1pdDogdGltZUxpbWl0LFxuICAgIGJpdFJhdGUsXG4gICAgYnVnUmVwb3J0LFxuICAgIHJlY29yZHM6IFtdLFxuICAgIHJlY29yZGluZ1Byb2Nlc3M6IG51bGwsXG4gICAgc3RvcHBlZDogZmFsc2UsXG4gIH07XG4gIGF3YWl0IHNjaGVkdWxlU2NyZWVuUmVjb3JkKHRoaXMuYWRiLCB0aGlzLl9zY3JlZW5SZWNvcmRpbmdQcm9wZXJ0aWVzKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU3RvcFJlY29yZGluZ09wdGlvbnNcbiAqXG4gKiBAcHJvcGVydHkgez9zdHJpbmd9IHJlbW90ZVBhdGggLSBUaGUgcGF0aCB0byB0aGUgcmVtb3RlIGxvY2F0aW9uLCB3aGVyZSB0aGUgcmVzdWx0aW5nIHZpZGVvIHNob3VsZCBiZSB1cGxvYWRlZC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBmb2xsb3dpbmcgcHJvdG9jb2xzIGFyZSBzdXBwb3J0ZWQ6IGh0dHAvaHR0cHMsIGZ0cC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE51bGwgb3IgZW1wdHkgc3RyaW5nIHZhbHVlICh0aGUgZGVmYXVsdCBzZXR0aW5nKSBtZWFucyB0aGUgY29udGVudCBvZiByZXN1bHRpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUgc2hvdWxkIGJlIGVuY29kZWQgYXMgQmFzZTY0IGFuZCBwYXNzZWQgYXMgdGhlIGVuZHBvdW50IHJlc3BvbnNlIHZhbHVlLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duIGlmIHRoZSBnZW5lcmF0ZWQgbWVkaWEgZmlsZSBpcyB0b28gYmlnIHRvXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXQgaW50byB0aGUgYXZhaWxhYmxlIHByb2Nlc3MgbWVtb3J5LlxuICogQHByb3BlcnR5IHs/c3RyaW5nfSB1c2VyIC0gVGhlIG5hbWUgb2YgdGhlIHVzZXIgZm9yIHRoZSByZW1vdGUgYXV0aGVudGljYXRpb24uXG4gKiBAcHJvcGVydHkgez9zdHJpbmd9IHBhc3MgLSBUaGUgcGFzc3dvcmQgZm9yIHRoZSByZW1vdGUgYXV0aGVudGljYXRpb24uXG4gKiBAcHJvcGVydHkgez9zdHJpbmd9IG1ldGhvZCAtIFRoZSBodHRwIG11bHRpcGFydCB1cGxvYWQgbWV0aG9kIG5hbWUuIFRoZSAnUFVUJyBvbmUgaXMgdXNlZCBieSBkZWZhdWx0LlxuICovXG5cbi8qKlxuICogU3RvcCByZWNvcmRpbmcgdGhlIHNjcmVlbi5cbiAqIElmIG5vIHNjcmVlbiByZWNvcmRpbmcgaGFzIGJlZW4gc3RhcnRlZCBiZWZvcmUgdGhlbiB0aGUgbWV0aG9kIHJldHVybnMgYW4gZW1wdHkgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7P1N0b3BSZWNvcmRpbmdPcHRpb25zfSBvcHRpb25zIC0gVGhlIGF2YWlsYWJsZSBvcHRpb25zLlxuICogQHJldHVybnMge3N0cmluZ30gQmFzZTY0LWVuY29kZWQgY29udGVudCBvZiB0aGUgcmVjb3JkZWQgbWVkaWEgZmlsZSBpZiAncmVtb3RlUGF0aCdcbiAqICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlciBpcyBmYWxzeSBvciBhbiBlbXB0eSBzdHJpbmcuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGdldHRpbmcgdGhlIG5hbWUgb2YgYSBtZWRpYSBmaWxlXG4gKiAgICAgICAgICAgICAgICAgb3IgdGhlIGZpbGUgY29udGVudCBjYW5ub3QgYmUgdXBsb2FkZWQgdG8gdGhlIHJlbW90ZSBsb2NhdGlvblxuICogICAgICAgICAgICAgICAgIG9yIHNjcmVlbiByZWNvcmRpbmcgaXMgbm90IHN1cHBvcnRlZCBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKi9cbmNvbW1hbmRzLnN0b3BSZWNvcmRpbmdTY3JlZW4gPSBhc3luYyBmdW5jdGlvbiAob3B0aW9ucyA9IHt9KSB7XG4gIGF3YWl0IHZlcmlmeVNjcmVlblJlY29yZElzU3VwcG9ydGVkKHRoaXMuYWRiLCB0aGlzLmlzRW11bGF0b3IoKSk7XG5cbiAgaWYgKCFfLmlzRW1wdHkodGhpcy5fc2NyZWVuUmVjb3JkaW5nUHJvcGVydGllcykpIHtcbiAgICB0aGlzLl9zY3JlZW5SZWNvcmRpbmdQcm9wZXJ0aWVzLnN0b3BwZWQgPSB0cnVlO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBhd2FpdCB0ZXJtaW5hdGVCYWNrZ3JvdW5kU2NyZWVuUmVjb3JkaW5nKHRoaXMuYWRiLCBmYWxzZSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGxvZy53YXJuKGVyci5tZXNzYWdlKTtcbiAgICBpZiAoIV8uaXNFbXB0eSh0aGlzLl9zY3JlZW5SZWNvcmRpbmdQcm9wZXJ0aWVzKSkge1xuICAgICAgbG9nLndhcm4oJ1RoZSByZXN1bHRpbmcgdmlkZW8gbWlnaHQgYmUgY29ycnVwdGVkJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKF8uaXNFbXB0eSh0aGlzLl9zY3JlZW5SZWNvcmRpbmdQcm9wZXJ0aWVzKSkge1xuICAgIGxvZy5pbmZvKGBTY3JlZW4gcmVjb3JkaW5nIGhhcyBub3QgYmVlbiBwcmV2aW91c2x5IHN0YXJ0ZWQgYnkgQXBwaXVtLiBUaGVyZSBpcyBub3RoaW5nIHRvIHN0b3BgKTtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodGhpcy5fc2NyZWVuUmVjb3JkaW5nUHJvcGVydGllcy5yZWNvcmRpbmdQcm9jZXNzICYmIHRoaXMuX3NjcmVlblJlY29yZGluZ1Byb3BlcnRpZXMucmVjb3JkaW5nUHJvY2Vzcy5pc1J1bm5pbmcpIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5fc2NyZWVuUmVjb3JkaW5nUHJvcGVydGllcy5yZWNvcmRpbmdQcm9jZXNzLnN0b3AoJ1NJR0lOVCcsIFBST0NFU1NfU0hVVERPV05fVElNRU9VVCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nLmVycm9yQW5kVGhyb3coYFVuYWJsZSB0byBzdG9wIHNjcmVlbiByZWNvcmRpbmcgd2l0aGluICR7UFJPQ0VTU19TSFVURE9XTl9USU1FT1VUfW1zYCk7XG4gICAgfVxuICAgIHRoaXMuX3NjcmVlblJlY29yZGluZ1Byb3BlcnRpZXMucmVjb3JkaW5nUHJvY2VzcyA9IG51bGw7XG4gIH1cblxuICBpZiAoXy5pc0VtcHR5KHRoaXMuX3NjcmVlblJlY29yZGluZ1Byb3BlcnRpZXMucmVjb3JkcykpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhgTm8gc2NyZWVuIHJlY29yZGluZ3MgaGF2ZSBiZWVuIHN0b3JlZCBvbiB0aGUgZGV2aWNlIHNvIGZhci4gYCArXG4gICAgICBgQXJlIHlvdSBzdXJlIHRoZSAke1NDUkVFTlJFQ09SRF9CSU5BUll9IHV0aWxpdHkgd29ya3MgYXMgZXhwZWN0ZWQ/YCk7XG4gIH1cblxuICBjb25zdCB0bXBSb290ID0gYXdhaXQgdGVtcERpci5vcGVuRGlyKCk7XG4gIHRyeSB7XG4gICAgY29uc3QgbG9jYWxSZWNvcmRzID0gW107XG4gICAgZm9yIChjb25zdCBwYXRoT25EZXZpY2Ugb2YgdGhpcy5fc2NyZWVuUmVjb3JkaW5nUHJvcGVydGllcy5yZWNvcmRzKSB7XG4gICAgICBsb2NhbFJlY29yZHMucHVzaChwYXRoLnJlc29sdmUodG1wUm9vdCwgcGF0aC5wb3NpeC5iYXNlbmFtZShwYXRoT25EZXZpY2UpKSk7XG4gICAgICBhd2FpdCB0aGlzLmFkYi5wdWxsKHBhdGhPbkRldmljZSwgXy5sYXN0KGxvY2FsUmVjb3JkcykpO1xuICAgICAgYXdhaXQgdGhpcy5hZGIucmltcmFmKHBhdGhPbkRldmljZSk7XG4gICAgfVxuICAgIGxldCByZXN1bHRGaWxlUGF0aCA9IF8ubGFzdChsb2NhbFJlY29yZHMpO1xuICAgIGlmIChsb2NhbFJlY29yZHMubGVuZ3RoID4gMSkge1xuICAgICAgbG9nLmluZm8oYEdvdCAke2xvY2FsUmVjb3Jkcy5sZW5ndGh9IHNjcmVlbiByZWNvcmRpbmdzLiBUcnlpbmcgdG8gbWVyZ2UgdGhlbWApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0RmlsZVBhdGggPSBhd2FpdCBtZXJnZVNjcmVlblJlY29yZHMobG9jYWxSZWNvcmRzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nLndhcm4oYENhbm5vdCBtZXJnZSB0aGUgcmVjb3JkZWQgZmlsZXMuIFRoZSBtb3N0IHJlY2VudCBzY3JlZW4gcmVjb3JkaW5nIGlzIGdvaW5nIHRvIGJlIHJldHVybmVkIGFzIHRoZSByZXN1bHQuIGAgK1xuICAgICAgICAgIGBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHtyZW1vdGVQYXRoLCB1c2VyLCBwYXNzLCBtZXRob2R9ID0gb3B0aW9ucztcbiAgICByZXR1cm4gYXdhaXQgdXBsb2FkUmVjb3JkZWRNZWRpYSh0aGlzLmFkYiwgcmVzdWx0RmlsZVBhdGgsIHJlbW90ZVBhdGgsIHt1c2VyLCBwYXNzLCBtZXRob2R9KTtcbiAgfSBmaW5hbGx5IHtcbiAgICBhd2FpdCBmcy5yaW1yYWYodG1wUm9vdCk7XG4gICAgdGhpcy5fc2NyZWVuUmVjb3JkaW5nUHJvcGVydGllcyA9IG51bGw7XG4gIH1cbn07XG5cblxuT2JqZWN0LmFzc2lnbihleHRlbnNpb25zLCBjb21tYW5kcyk7XG5leHBvcnQgeyBjb21tYW5kcyB9O1xuZXhwb3J0IGRlZmF1bHQgZXh0ZW5zaW9ucztcbiJdLCJzb3VyY2VSb290IjoiLi4vLi4vLi4ifQ==
