'use strict';

var _slicedToArray = require('babel-runtime/helpers/sliced-to-array')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _teen_process = require('teen_process');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _loggerJs = require('../logger.js');

var _loggerJs2 = _interopRequireDefault(_loggerJs);

var _appiumSupport = require('appium-support');

var _helpersJs = require('../helpers.js');

var DEFAULT_PRIVATE_KEY = _path2['default'].resolve(_helpersJs.rootDir, 'keys', 'testkey.pk8');
var DEFAULT_CERTIFICATE = _path2['default'].resolve(_helpersJs.rootDir, 'keys', 'testkey.x509.pem');
var DEFAULT_CERT_DIGEST = 'a40da80a59d170caa950cf15c18c454d47a39b26989d8b640ecd745ba71bf5dc';

var apkSigningMethods = {};

/**
 * Applies the patch, which workarounds'-Djava.ext.dirs is not supported. Use -classpath instead.'
 * error on Windows by creating a temporary patched copy of the original apksigner script.
 *
 * @param {string} originalPath - The original path to apksigner tool
 * @returns {string} The full path to the patched script or the same path if there is
 *                   no need to patch the original file.
 */
function patchApksigner(originalPath) {
  var originalContent, patchedContent, patchedPath;
  return _regeneratorRuntime.async(function patchApksigner$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.readFile(originalPath, 'ascii'));

      case 2:
        originalContent = context$1$0.sent;
        patchedContent = originalContent.replace('-Djava.ext.dirs="%frameworkdir%"', '-cp "%frameworkdir%\\*"');

        if (!(patchedContent === originalContent)) {
          context$1$0.next = 6;
          break;
        }

        return context$1$0.abrupt('return', originalPath);

      case 6:
        _loggerJs2['default'].debug('Patching \'' + originalPath + '...');
        context$1$0.next = 9;
        return _regeneratorRuntime.awrap(_appiumSupport.tempDir.path({ prefix: 'apksigner', suffix: '.bat' }));

      case 9:
        patchedPath = context$1$0.sent;
        context$1$0.next = 12;
        return _regeneratorRuntime.awrap((0, _appiumSupport.mkdirp)(_path2['default'].dirname(patchedPath)));

      case 12:
        context$1$0.next = 14;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.writeFile(patchedPath, patchedContent, 'ascii'));

      case 14:
        return context$1$0.abrupt('return', patchedPath);

      case 15:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

/**
 * Execute apksigner utility with given arguments.
 *
 * @param {?Array<String>} args - The list of tool arguments.
 * @return {string} - Command stdout
 * @throws {Error} If apksigner binary is not present on the local file system
 *                 or the return code is not equal to zero.
 */
apkSigningMethods.executeApksigner = function callee$0$0() {
  var args = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];

  var apkSigner, originalFolder, getApksignerOutput, _arr2, _i2, _arr2$_i2, _name2, stream, patchedApksigner;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap((0, _helpersJs.getApksignerForOs)(this));

      case 2:
        apkSigner = context$1$0.sent;
        originalFolder = _path2['default'].dirname(apkSigner);

        getApksignerOutput = function getApksignerOutput(apksignerPath) {
          var _ref, stdout, stderr, _arr, _i, _arr$_i, _name, stream;

          return _regeneratorRuntime.async(function getApksignerOutput$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.next = 2;
                return _regeneratorRuntime.awrap((0, _teen_process.exec)(apksignerPath, args, {
                  cwd: originalFolder
                }));

              case 2:
                _ref = context$2$0.sent;
                stdout = _ref.stdout;
                stderr = _ref.stderr;
                _arr = [['stdout', stdout], ['stderr', stderr]];

                for (_i = 0; _i < _arr.length; _i++) {
                  _arr$_i = _slicedToArray(_arr[_i], 2);
                  _name = _arr$_i[0];
                  stream = _arr$_i[1];

                  if (stream) {
                    _loggerJs2['default'].debug('apksigner ' + _name + ': ' + stream);
                  }
                }
                return context$2$0.abrupt('return', stdout);

              case 8:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this);
        };

        _loggerJs2['default'].debug('Starting \'' + apkSigner + '\' with args \'' + JSON.stringify(args) + '\'');
        context$1$0.prev = 6;
        context$1$0.next = 9;
        return _regeneratorRuntime.awrap(getApksignerOutput(apkSigner));

      case 9:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 12:
        context$1$0.prev = 12;
        context$1$0.t0 = context$1$0['catch'](6);

        _loggerJs2['default'].warn('Got an error during apksigner execution: ' + context$1$0.t0.message);
        _arr2 = [['stdout', context$1$0.t0.stdout], ['stderr', context$1$0.t0.stderr]];
        for (_i2 = 0; _i2 < _arr2.length; _i2++) {
          _arr2$_i2 = _slicedToArray(_arr2[_i2], 2);
          _name2 = _arr2$_i2[0];
          stream = _arr2$_i2[1];

          if (stream) {
            _loggerJs2['default'].warn('apksigner ' + _name2 + ': ' + stream);
          }
        }

        if (!_appiumSupport.system.isWindows()) {
          context$1$0.next = 30;
          break;
        }

        context$1$0.next = 20;
        return _regeneratorRuntime.awrap(patchApksigner(apkSigner));

      case 20:
        patchedApksigner = context$1$0.sent;

        if (!(patchedApksigner !== apkSigner)) {
          context$1$0.next = 30;
          break;
        }

        context$1$0.prev = 22;
        context$1$0.next = 25;
        return _regeneratorRuntime.awrap(getApksignerOutput(patchedApksigner));

      case 25:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 26:
        context$1$0.prev = 26;
        context$1$0.next = 29;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.unlink(patchedApksigner));

      case 29:
        return context$1$0.finish(26);

      case 30:
        throw context$1$0.t0;

      case 31:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[6, 12], [22,, 26, 30]]);
};

/**
 * (Re)sign the given apk file on the local file system with the default certificate.
 *
 * @param {string} apk - The full path to the local apk file.
 * @throws {Error} If signing fails.
 */
apkSigningMethods.signWithDefaultCert = function callee$0$0(apk) {
  var args, java, signPath;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug('Signing \'' + apk + '\' with default cert');
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(apk));

      case 3:
        if (context$1$0.sent) {
          context$1$0.next = 5;
          break;
        }

        throw new Error(apk + ' file doesn\'t exist.');

      case 5:
        context$1$0.prev = 5;
        args = ['sign', '--key', DEFAULT_PRIVATE_KEY, '--cert', DEFAULT_CERTIFICATE, apk];
        context$1$0.next = 9;
        return _regeneratorRuntime.awrap(this.executeApksigner(args));

      case 9:
        context$1$0.next = 25;
        break;

      case 11:
        context$1$0.prev = 11;
        context$1$0.t0 = context$1$0['catch'](5);

        _loggerJs2['default'].warn('Cannot use apksigner tool for signing. Defaulting to sign.jar. ' + ('Original error: ' + context$1$0.t0.message) + (context$1$0.t0.stderr ? '; StdErr: ' + context$1$0.t0.stderr : ''));
        java = (0, _helpersJs.getJavaForOs)();
        signPath = _path2['default'].resolve(this.helperJarPath, 'sign.jar');

        _loggerJs2['default'].debug("Resigning apk.");
        context$1$0.prev = 17;
        context$1$0.next = 20;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(java, ['-jar', signPath, apk, '--override']));

      case 20:
        context$1$0.next = 25;
        break;

      case 22:
        context$1$0.prev = 22;
        context$1$0.t1 = context$1$0['catch'](17);
        throw new Error('Could not sign with default certificate. Original error ' + context$1$0.t1.message);

      case 25:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[5, 11], [17, 22]]);
};

/**
 * (Re)sign the given apk file on the local file system with a custom certificate.
 *
 * @param {string} apk - The full path to the local apk file.
 * @throws {Error} If signing fails.
 */
apkSigningMethods.signWithCustomCert = function callee$0$0(apk) {
  var args, jarsigner;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug('Signing \'' + apk + '\' with custom cert');
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(this.keystorePath));

      case 3:
        if (context$1$0.sent) {
          context$1$0.next = 5;
          break;
        }

        throw new Error('Keystore: ' + this.keystorePath + ' doesn\'t exist.');

      case 5:
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(apk));

      case 7:
        if (context$1$0.sent) {
          context$1$0.next = 9;
          break;
        }

        throw new Error('\'' + apk + '\' doesn\'t exist.');

      case 9:
        context$1$0.prev = 9;
        args = ['sign', '--ks', this.keystorePath, '--ks-key-alias', this.keyAlias, '--ks-pass', 'pass:' + this.keystorePassword, '--key-pass', 'pass:' + this.keyPassword, apk];
        context$1$0.next = 13;
        return _regeneratorRuntime.awrap(this.executeApksigner(args));

      case 13:
        context$1$0.next = 31;
        break;

      case 15:
        context$1$0.prev = 15;
        context$1$0.t0 = context$1$0['catch'](9);

        _loggerJs2['default'].warn('Cannot use apksigner tool for signing. Defaulting to jarsigner. ' + ('Original error: ' + context$1$0.t0.message));
        context$1$0.prev = 18;

        _loggerJs2['default'].debug("Unsigning apk.");
        context$1$0.next = 22;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)((0, _helpersJs.getJavaForOs)(), ['-jar', _path2['default'].resolve(this.helperJarPath, 'unsign.jar'), apk]));

      case 22:
        _loggerJs2['default'].debug("Signing apk.");
        jarsigner = _path2['default'].resolve((0, _helpersJs.getJavaHome)(), 'bin', 'jarsigner' + (_appiumSupport.system.isWindows() ? '.exe' : ''));
        context$1$0.next = 26;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(jarsigner, ['-sigalg', 'MD5withRSA', '-digestalg', 'SHA1', '-keystore', this.keystorePath, '-storepass', this.keystorePassword, '-keypass', this.keyPassword, apk, this.keyAlias]));

      case 26:
        context$1$0.next = 31;
        break;

      case 28:
        context$1$0.prev = 28;
        context$1$0.t1 = context$1$0['catch'](18);
        throw new Error('Could not sign with custom certificate. Original error ' + context$1$0.t1.message);

      case 31:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[9, 15], [18, 28]]);
};

/**
 * (Re)sign the given apk file on the local file system with either
 * custom or default certificate based on _this.useKeystore_ property value
 * and Zip-aligns it after signing.
 *
 * @param {string} apk - The full path to the local apk file.
 * @throws {Error} If signing fails.
 */
apkSigningMethods.sign = function callee$0$0(apk) {
  var apksignerFound;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        apksignerFound = true;
        context$1$0.prev = 1;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap((0, _helpersJs.getApksignerForOs)(this));

      case 4:
        context$1$0.next = 9;
        break;

      case 6:
        context$1$0.prev = 6;
        context$1$0.t0 = context$1$0['catch'](1);

        apksignerFound = false;

      case 9:
        if (!apksignerFound) {
          context$1$0.next = 12;
          break;
        }

        context$1$0.next = 12;
        return _regeneratorRuntime.awrap(this.zipAlignApk(apk));

      case 12:
        if (!this.useKeystore) {
          context$1$0.next = 17;
          break;
        }

        context$1$0.next = 15;
        return _regeneratorRuntime.awrap(this.signWithCustomCert(apk));

      case 15:
        context$1$0.next = 19;
        break;

      case 17:
        context$1$0.next = 19;
        return _regeneratorRuntime.awrap(this.signWithDefaultCert(apk));

      case 19:
        if (apksignerFound) {
          context$1$0.next = 22;
          break;
        }

        context$1$0.next = 22;
        return _regeneratorRuntime.awrap(this.zipAlignApk(apk));

      case 22:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[1, 6]]);
};

/**
 * Perform zip-aligning to the given local apk file.
 *
 * @param {string} apk - The full path to the local apk file.
 * @returns {boolean} True if the apk has been successfully aligned
 * or false if the apk has been already aligned.
 * @throws {Error} If zip-align fails.
 */
apkSigningMethods.zipAlignApk = function callee$0$0(apk) {
  var alignedApk;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.initZipAlign());

      case 2:
        context$1$0.prev = 2;
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(this.binaries.zipalign, ['-c', '4', apk]));

      case 5:
        _loggerJs2['default'].debug(apk + '\' is already zip-aligned. Doing nothing');
        return context$1$0.abrupt('return', false);

      case 9:
        context$1$0.prev = 9;
        context$1$0.t0 = context$1$0['catch'](2);

        _loggerJs2['default'].debug('\'' + apk + '\' is not zip-aligned. Aligning');

      case 12:
        context$1$0.next = 14;
        return _regeneratorRuntime.awrap(_appiumSupport.tempDir.path({ prefix: 'appium', suffix: '.tmp' }));

      case 14:
        alignedApk = context$1$0.sent;
        context$1$0.next = 17;
        return _regeneratorRuntime.awrap((0, _appiumSupport.mkdirp)(_path2['default'].dirname(alignedApk)));

      case 17:
        context$1$0.prev = 17;
        context$1$0.next = 20;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(this.binaries.zipalign, ['-f', '4', apk, alignedApk]));

      case 20:
        context$1$0.next = 22;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.mv(alignedApk, apk, { mkdirp: true }));

      case 22:
        return context$1$0.abrupt('return', true);

      case 25:
        context$1$0.prev = 25;
        context$1$0.t1 = context$1$0['catch'](17);
        context$1$0.next = 29;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(alignedApk));

      case 29:
        if (!context$1$0.sent) {
          context$1$0.next = 32;
          break;
        }

        context$1$0.next = 32;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.unlink(alignedApk));

      case 32:
        throw new Error('zipAlignApk failed. Original error: ' + context$1$0.t1.message + '. Stdout: \'' + context$1$0.t1.stdout + '\'; Stderr: \'' + context$1$0.t1.stderr + '\'');

      case 33:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[2, 9], [17, 25]]);
};

/**
 * Check if the app is already signed with the default Appium ceritficate.
 *
 * @param {string} apk - The full path to the local apk file.
 * @param {string} pgk - The name of application package.
 * @return {boolean} True if given application is already signed.
 */
apkSigningMethods.checkApkCert = function callee$0$0(apk, pkg) {
  var verificationFunc;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this2 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug('Checking app cert for ' + apk);
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(apk));

      case 3:
        if (context$1$0.sent) {
          context$1$0.next = 6;
          break;
        }

        _loggerJs2['default'].debug('\'' + apk + '\' doesn\'t exist');
        return context$1$0.abrupt('return', false);

      case 6:
        if (!this.useKeystore) {
          context$1$0.next = 10;
          break;
        }

        context$1$0.next = 9;
        return _regeneratorRuntime.awrap(this.checkCustomApkCert(apk, pkg));

      case 9:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 10:
        verificationFunc = undefined;
        context$1$0.prev = 11;
        context$1$0.next = 14;
        return _regeneratorRuntime.awrap((0, _helpersJs.getApksignerForOs)(this));

      case 14:
        verificationFunc = function callee$1$0() {
          var output;
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.next = 2;
                return _regeneratorRuntime.awrap(this.executeApksigner(['verify', '--print-certs', apk]));

              case 2:
                output = context$2$0.sent;

                if (_lodash2['default'].includes(output, DEFAULT_CERT_DIGEST)) {
                  context$2$0.next = 5;
                  break;
                }

                throw new Error('\'' + apk + '\' is signed with non-default certificate');

              case 5:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this2);
        };
        context$1$0.next = 20;
        break;

      case 17:
        context$1$0.prev = 17;
        context$1$0.t0 = context$1$0['catch'](11);

        (function () {
          _loggerJs2['default'].warn('Cannot use apksigner tool for signature verification. Defaulting to verify.jar. ' + ('Original error: ' + context$1$0.t0.message));
          var java = (0, _helpersJs.getJavaForOs)();
          verificationFunc = function callee$3$0() {
            return _regeneratorRuntime.async(function callee$3$0$(context$4$0) {
              while (1) switch (context$4$0.prev = context$4$0.next) {
                case 0:
                  context$4$0.next = 2;
                  return _regeneratorRuntime.awrap((0, _teen_process.exec)(java, ['-jar', _path2['default'].resolve(this.helperJarPath, 'verify.jar'), apk]));

                case 2:
                  return context$4$0.abrupt('return', context$4$0.sent);

                case 3:
                case 'end':
                  return context$4$0.stop();
              }
            }, null, _this2);
          };
        })();

      case 20:
        context$1$0.prev = 20;
        context$1$0.next = 23;
        return _regeneratorRuntime.awrap(verificationFunc());

      case 23:
        _loggerJs2['default'].debug('\'' + apk + '\' is already signed.');
        return context$1$0.abrupt('return', true);

      case 27:
        context$1$0.prev = 27;
        context$1$0.t1 = context$1$0['catch'](20);

        _loggerJs2['default'].debug('\'' + apk + '\' is not signed with debug cert.');
        return context$1$0.abrupt('return', false);

      case 31:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[11, 17], [20, 27]]);
};

/**
 * Check if the app is already signed with a custom certificate.
 *
 * @param {string} apk - The full path to the local apk file.
 * @param {string} pgk - The name of application package.
 * @return {boolean} True if given application is already signed with a custom certificate.
 */
apkSigningMethods.checkCustomApkCert = function callee$0$0(apk, pkg) {
  var h, md5Str, md5, javaHome, keytool, keystoreHash;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug('Checking custom app cert for ' + apk);
        h = "a-fA-F0-9";
        md5Str = ['.*MD5.*((?:[' + h + ']{2}:){15}[' + h + ']{2})'];
        md5 = new RegExp(md5Str, 'mi');
        javaHome = (0, _helpersJs.getJavaHome)();
        keytool = _path2['default'].resolve(javaHome, 'bin', 'keytool' + (_appiumSupport.system.isWindows() ? '.exe' : ''));
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(this.getKeystoreMd5(keytool, md5));

      case 8:
        keystoreHash = context$1$0.sent;
        context$1$0.next = 11;
        return _regeneratorRuntime.awrap(this.checkApkKeystoreMatch(keytool, md5, keystoreHash, pkg, apk));

      case 11:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 12:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Get the MD5 hash of the keystore.
 *
 * @param {string} keytool - The name of the keytool utility.
 * @param {RegExp} md5re - The pattern used to match the result in _keytool_ output.
 * @return {?string} Keystore MD5 hash or _null_ if the hash cannot be parsed.
 * @throws {Error} If getting keystore MD5 hash fails.
 */
apkSigningMethods.getKeystoreMd5 = function callee$0$0(keytool, md5re) {
  var _ref2, stdout, keystoreHash;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug("Printing keystore md5.");
        context$1$0.prev = 1;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(keytool, ['-v', '-list', '-alias', this.keyAlias, '-keystore', this.keystorePath, '-storepass', this.keystorePassword]));

      case 4:
        _ref2 = context$1$0.sent;
        stdout = _ref2.stdout;
        keystoreHash = md5re.exec(stdout);

        keystoreHash = keystoreHash ? keystoreHash[1] : null;
        _loggerJs2['default'].debug('Keystore MD5: ' + keystoreHash);
        return context$1$0.abrupt('return', keystoreHash);

      case 12:
        context$1$0.prev = 12;
        context$1$0.t0 = context$1$0['catch'](1);
        throw new Error('getKeystoreMd5 failed. Original error: ' + context$1$0.t0.message);

      case 15:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[1, 12]]);
};

/**
 * Check if the MD5 hash of the particular application matches to the given hash.
 *
 * @param {string} keytool - The name of the keytool utility.
 * @param {RegExp} md5re - The pattern used to match the result in _keytool_ output.
 * @param {string} keystoreHash - The expected hash value.
 * @param {string} pkg - The name of the installed package.
 * @param {string} apk - The full path to the existing apk file.
 * @return {boolean} True if both hashes are equal.
 * @throws {Error} If getting keystore MD5 hash fails.
 */
apkSigningMethods.checkApkKeystoreMatch = function callee$0$0(keytool, md5re, keystoreHash, pkg, apk) {
  var entryHash, rsa, foundKeystoreMatch;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this3 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        entryHash = null;
        rsa = /^META-INF\/.*\.[rR][sS][aA]$/;
        foundKeystoreMatch = false;
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(_appiumSupport.zip.readEntries(apk, function callee$1$0(_ref3) {
          var entry = _ref3.entry;
          var extractEntryTo = _ref3.extractEntryTo;

          var entryPath, entryFile, _ref4, stdout, matchesKeystore;

          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                entry = entry.fileName;

                if (rsa.test(entry)) {
                  context$2$0.next = 3;
                  break;
                }

                return context$2$0.abrupt('return');

              case 3:
                _loggerJs2['default'].debug('Entry: ' + entry);
                entryPath = _path2['default'].join(this.tmpDir, pkg, 'cert');

                _loggerJs2['default'].debug('entryPath: ' + entryPath);
                entryFile = _path2['default'].join(entryPath, entry);

                _loggerJs2['default'].debug('entryFile: ' + entryFile);
                // ensure /tmp/pkg/cert/ doesn't exist or extract will fail.
                context$2$0.next = 10;
                return _regeneratorRuntime.awrap(_appiumSupport.fs.rimraf(entryPath));

              case 10:
                context$2$0.next = 12;
                return _regeneratorRuntime.awrap(extractEntryTo(entryPath));

              case 12:
                _loggerJs2['default'].debug("extracted!");
                // check for match
                _loggerJs2['default'].debug("Printing apk md5.");
                context$2$0.next = 16;
                return _regeneratorRuntime.awrap((0, _teen_process.exec)(keytool, ['-v', '-printcert', '-file', entryFile]));

              case 16:
                _ref4 = context$2$0.sent;
                stdout = _ref4.stdout;

                entryHash = md5re.exec(stdout);
                entryHash = entryHash ? entryHash[1] : null;
                _loggerJs2['default'].debug('entryHash MD5: ' + entryHash);
                _loggerJs2['default'].debug('keystore MD5: ' + keystoreHash);
                matchesKeystore = entryHash && entryHash === keystoreHash;

                _loggerJs2['default'].debug('Matches keystore? ' + matchesKeystore);

                // If we have a keystore match, stop iterating

                if (!matchesKeystore) {
                  context$2$0.next = 27;
                  break;
                }

                foundKeystoreMatch = true;
                return context$2$0.abrupt('return', false);

              case 27:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this3);
        }));

      case 5:
        return context$1$0.abrupt('return', foundKeystoreMatch);

      case 6:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

exports['default'] = apkSigningMethods;
module.exports = exports['default'];

// it is necessary to apply zipalign only before signing
// if apksigner is used or only after signing if we only have
// sign.jar utility

//for (let entry of entries) {
// META-INF/CERT.RSA
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi90b29scy9hcGstc2lnbmluZy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7c0JBQWMsUUFBUTs7Ozs0QkFDRCxjQUFjOztvQkFDbEIsTUFBTTs7Ozt3QkFDUCxjQUFjOzs7OzZCQUNtQixnQkFBZ0I7O3lCQUNLLGVBQWU7O0FBRXJGLElBQU0sbUJBQW1CLEdBQUcsa0JBQUssT0FBTyxxQkFBVSxNQUFNLEVBQUUsYUFBYSxDQUFDLENBQUM7QUFDekUsSUFBTSxtQkFBbUIsR0FBRyxrQkFBSyxPQUFPLHFCQUFVLE1BQU0sRUFBRSxrQkFBa0IsQ0FBQyxDQUFDO0FBQzlFLElBQU0sbUJBQW1CLEdBQUcsa0VBQWtFLENBQUM7O0FBRS9GLElBQUksaUJBQWlCLEdBQUcsRUFBRSxDQUFDOzs7Ozs7Ozs7O0FBVTNCLFNBQWUsY0FBYyxDQUFFLFlBQVk7TUFDbkMsZUFBZSxFQUNmLGNBQWMsRUFNZCxXQUFXOzs7Ozt5Q0FQYSxrQkFBRyxRQUFRLENBQUMsWUFBWSxFQUFFLE9BQU8sQ0FBQzs7O0FBQTFELHVCQUFlO0FBQ2Ysc0JBQWMsR0FBRyxlQUFlLENBQUMsT0FBTyxDQUFDLGtDQUFrQyxFQUMvRSx5QkFBeUIsQ0FBQzs7Y0FDeEIsY0FBYyxLQUFLLGVBQWUsQ0FBQTs7Ozs7NENBQzdCLFlBQVk7OztBQUVyQiw4QkFBSSxLQUFLLGlCQUFjLFlBQVksU0FBTSxDQUFDOzt5Q0FDaEIsdUJBQVEsSUFBSSxDQUFDLEVBQUMsTUFBTSxFQUFFLFdBQVcsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFDLENBQUM7OztBQUF2RSxtQkFBVzs7eUNBQ1gsMkJBQU8sa0JBQUssT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDOzs7O3lDQUNqQyxrQkFBRyxTQUFTLENBQUMsV0FBVyxFQUFFLGNBQWMsRUFBRSxPQUFPLENBQUM7Ozs0Q0FDakQsV0FBVzs7Ozs7OztDQUNuQjs7Ozs7Ozs7OztBQVVELGlCQUFpQixDQUFDLGdCQUFnQixHQUFHO01BQWdCLElB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Q0FBQztBQUN2QywrQkFBZSxHQUFHLFNBQVMsSUFBSSxTQUFTLEtBQUssWUFBWTs7QUFDN0Qsc0NBQUksS0FBSyx3QkFBc0IsZUFBZSxDQUFHLENBQUM7Ozs7cUJBRzlDLGVBQWU7Ozs7O0FBQ2pCLGtDQUFrQixHQUFHLElBQUksQ0FBQztvREFDbkIsS0FBSzs7Ozs7OztTQUVmLENBQUM7Ozs0Q0FDSyxrQkFBa0I7Ozs7Ozs7Q0FDMUIsQ0FBQzs7cUJBRWEsaUJBQWlCIiwiZmlsZSI6ImxpYi90b29scy9hcGstc2lnbmluZy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBleGVjIH0gZnJvbSAndGVlbl9wcm9jZXNzJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IGxvZyBmcm9tICcuLi9sb2dnZXIuanMnO1xuaW1wb3J0IHsgdGVtcERpciwgc3lzdGVtLCBta2RpcnAsIGZzLCB6aXAgfSBmcm9tICdhcHBpdW0tc3VwcG9ydCc7XG5pbXBvcnQgeyBnZXRKYXZhRm9yT3MsIGdldEFwa3NpZ25lckZvck9zLCBnZXRKYXZhSG9tZSwgcm9vdERpciB9IGZyb20gJy4uL2hlbHBlcnMuanMnO1xuXG5jb25zdCBERUZBVUxUX1BSSVZBVEVfS0VZID0gcGF0aC5yZXNvbHZlKHJvb3REaXIsICdrZXlzJywgJ3Rlc3RrZXkucGs4Jyk7XG5jb25zdCBERUZBVUxUX0NFUlRJRklDQVRFID0gcGF0aC5yZXNvbHZlKHJvb3REaXIsICdrZXlzJywgJ3Rlc3RrZXkueDUwOS5wZW0nKTtcbmNvbnN0IERFRkFVTFRfQ0VSVF9ESUdFU1QgPSAnYTQwZGE4MGE1OWQxNzBjYWE5NTBjZjE1YzE4YzQ1NGQ0N2EzOWIyNjk4OWQ4YjY0MGVjZDc0NWJhNzFiZjVkYyc7XG5cbmxldCBhcGtTaWduaW5nTWV0aG9kcyA9IHt9O1xuXG4vKipcbiAqIEFwcGxpZXMgdGhlIHBhdGNoLCB3aGljaCB3b3JrYXJvdW5kcyctRGphdmEuZXh0LmRpcnMgaXMgbm90IHN1cHBvcnRlZC4gVXNlIC1jbGFzc3BhdGggaW5zdGVhZC4nXG4gKiBlcnJvciBvbiBXaW5kb3dzIGJ5IGNyZWF0aW5nIGEgdGVtcG9yYXJ5IHBhdGNoZWQgY29weSBvZiB0aGUgb3JpZ2luYWwgYXBrc2lnbmVyIHNjcmlwdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gb3JpZ2luYWxQYXRoIC0gVGhlIG9yaWdpbmFsIHBhdGggdG8gYXBrc2lnbmVyIHRvb2xcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmdWxsIHBhdGggdG8gdGhlIHBhdGNoZWQgc2NyaXB0IG9yIHRoZSBzYW1lIHBhdGggaWYgdGhlcmUgaXNcbiAqICAgICAgICAgICAgICAgICAgIG5vIG5lZWQgdG8gcGF0Y2ggdGhlIG9yaWdpbmFsIGZpbGUuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHBhdGNoQXBrc2lnbmVyIChvcmlnaW5hbFBhdGgpIHtcbiAgY29uc3Qgb3JpZ2luYWxDb250ZW50ID0gYXdhaXQgZnMucmVhZEZpbGUob3JpZ2luYWxQYXRoLCAnYXNjaWknKTtcbiAgY29uc3QgcGF0Y2hlZENvbnRlbnQgPSBvcmlnaW5hbENvbnRlbnQucmVwbGFjZSgnLURqYXZhLmV4dC5kaXJzPVwiJWZyYW1ld29ya2RpciVcIicsXG4gICAgJy1jcCBcIiVmcmFtZXdvcmtkaXIlXFxcXCpcIicpO1xuICBpZiAocGF0Y2hlZENvbnRlbnQgPT09IG9yaWdpbmFsQ29udGVudCkge1xuICAgIHJldHVybiBvcmlnaW5hbFBhdGg7XG4gIH1cbiAgbG9nLmRlYnVnKGBQYXRjaGluZyAnJHtvcmlnaW5hbFBhdGh9Li4uYCk7XG4gIGNvbnN0IHBhdGNoZWRQYXRoID0gYXdhaXQgdGVtcERpci5wYXRoKHtwcmVmaXg6ICdhcGtzaWduZXInLCBzdWZmaXg6ICcuYmF0J30pO1xuICBhd2FpdCBta2RpcnAocGF0aC5kaXJuYW1lKHBhdGNoZWRQYXRoKSk7XG4gIGF3YWl0IGZzLndyaXRlRmlsZShwYXRjaGVkUGF0aCwgcGF0Y2hlZENvbnRlbnQsICdhc2NpaScpO1xuICByZXR1cm4gcGF0Y2hlZFBhdGg7XG59XG5cbi8qKlxuICogRXhlY3V0ZSBhcGtzaWduZXIgdXRpbGl0eSB3aXRoIGdpdmVuIGFyZ3VtZW50cy5cbiAqXG4gKiBAcGFyYW0gez9BcnJheTxTdHJpbmc+fSBhcmdzIC0gVGhlIGxpc3Qgb2YgdG9vbCBhcmd1bWVudHMuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IC0gQ29tbWFuZCBzdGRvdXRcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBhcGtzaWduZXIgYmluYXJ5IGlzIG5vdCBwcmVzZW50IG9uIHRoZSBsb2NhbCBmaWxlIHN5c3RlbVxuICogICAgICAgICAgICAgICAgIG9yIHRoZSByZXR1cm4gY29kZSBpcyBub3QgZXF1YWwgdG8gemVyby5cbiAqL1xuYXBrU2lnbmluZ01ldGhvZHMuZXhlY3V0ZUFwa3NpZ25lciA9IGFzeW5jIGZ1bmN0aW9uIChhcmdzID0gW10pIHtcbiAgY29uc3QgYXBrU2lnbmVyID0gYXdhaXQgZ2V0QXBrc2lnbmVyRm9yT3ModGhpcyk7XG4gIGNvbnN0IG9yaWdpbmFsRm9sZGVyID0gcGF0aC5kaXJuYW1lKGFwa1NpZ25lcik7XG4gIGNvbnN0IGdldEFwa3NpZ25lck91dHB1dCA9IGFzeW5jIChhcGtzaWduZXJQYXRoKSA9PiB7XG4gICAgY29uc3Qge3N0ZG91dCwgc3RkZXJyfSA9IGF3YWl0IGV4ZWMoYXBrc2lnbmVyUGF0aCwgYXJncywge1xuICAgICAgY3dkOiBvcmlnaW5hbEZvbGRlcixcbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IFtuYW1lLCBzdHJlYW1dIG9mIFtbJ3N0ZG91dCcsIHN0ZG91dF0sIFsnc3RkZXJyJywgc3RkZXJyXV0pIHtcbiAgICAgIGlmIChzdHJlYW0pIHtcbiAgICAgICAgbG9nLmRlYnVnKGBhcGtzaWduZXIgJHtuYW1lfTogJHtzdHJlYW19YCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdGRvdXQ7XG4gIH07XG4gIGxvZy5kZWJ1ZyhgU3RhcnRpbmcgJyR7YXBrU2lnbmVyfScgd2l0aCBhcmdzICcke0pTT04uc3RyaW5naWZ5KGFyZ3MpfSdgKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgZ2V0QXBrc2lnbmVyT3V0cHV0KGFwa1NpZ25lcik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGxvZy53YXJuKGBHb3QgYW4gZXJyb3IgZHVyaW5nIGFwa3NpZ25lciBleGVjdXRpb246ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgZm9yIChjb25zdCBbbmFtZSwgc3RyZWFtXSBvZiBbWydzdGRvdXQnLCBlcnIuc3Rkb3V0XSwgWydzdGRlcnInLCBlcnIuc3RkZXJyXV0pIHtcbiAgICAgIGlmIChzdHJlYW0pIHtcbiAgICAgICAgbG9nLndhcm4oYGFwa3NpZ25lciAke25hbWV9OiAke3N0cmVhbX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN5c3RlbS5pc1dpbmRvd3MoKSkge1xuICAgICAgY29uc3QgcGF0Y2hlZEFwa3NpZ25lciA9IGF3YWl0IHBhdGNoQXBrc2lnbmVyKGFwa1NpZ25lcik7XG4gICAgICBpZiAocGF0Y2hlZEFwa3NpZ25lciAhPT0gYXBrU2lnbmVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IGdldEFwa3NpZ25lck91dHB1dChwYXRjaGVkQXBrc2lnbmVyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBhd2FpdCBmcy51bmxpbmsocGF0Y2hlZEFwa3NpZ25lcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgZXJyO1xuICB9XG59O1xuXG4vKipcbiAqIChSZSlzaWduIHRoZSBnaXZlbiBhcGsgZmlsZSBvbiB0aGUgbG9jYWwgZmlsZSBzeXN0ZW0gd2l0aCB0aGUgZGVmYXVsdCBjZXJ0aWZpY2F0ZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXBrIC0gVGhlIGZ1bGwgcGF0aCB0byB0aGUgbG9jYWwgYXBrIGZpbGUuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgc2lnbmluZyBmYWlscy5cbiAqL1xuYXBrU2lnbmluZ01ldGhvZHMuc2lnbldpdGhEZWZhdWx0Q2VydCA9IGFzeW5jIGZ1bmN0aW9uIChhcGspIHtcbiAgbG9nLmRlYnVnKGBTaWduaW5nICcke2Fwa30nIHdpdGggZGVmYXVsdCBjZXJ0YCk7XG4gIGlmICghKGF3YWl0IGZzLmV4aXN0cyhhcGspKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHthcGt9IGZpbGUgZG9lc24ndCBleGlzdC5gKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgYXJncyA9IFsnc2lnbicsXG4gICAgICAnLS1rZXknLCBERUZBVUxUX1BSSVZBVEVfS0VZLFxuICAgICAgJy0tY2VydCcsIERFRkFVTFRfQ0VSVElGSUNBVEUsXG4gICAgICBhcGtdO1xuICAgIGF3YWl0IHRoaXMuZXhlY3V0ZUFwa3NpZ25lcihhcmdzKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgbG9nLndhcm4oYENhbm5vdCB1c2UgYXBrc2lnbmVyIHRvb2wgZm9yIHNpZ25pbmcuIERlZmF1bHRpbmcgdG8gc2lnbi5qYXIuIGAgK1xuICAgICAgICAgICAgIGBPcmlnaW5hbCBlcnJvcjogJHtlcnIubWVzc2FnZX1gICsgKGVyci5zdGRlcnIgPyBgOyBTdGRFcnI6ICR7ZXJyLnN0ZGVycn1gIDogJycpKTtcbiAgICBjb25zdCBqYXZhID0gZ2V0SmF2YUZvck9zKCk7XG4gICAgY29uc3Qgc2lnblBhdGggPSBwYXRoLnJlc29sdmUodGhpcy5oZWxwZXJKYXJQYXRoLCAnc2lnbi5qYXInKTtcbiAgICBsb2cuZGVidWcoXCJSZXNpZ25pbmcgYXBrLlwiKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgZXhlYyhqYXZhLCBbJy1qYXInLCBzaWduUGF0aCwgYXBrLCAnLS1vdmVycmlkZSddKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBzaWduIHdpdGggZGVmYXVsdCBjZXJ0aWZpY2F0ZS4gT3JpZ2luYWwgZXJyb3IgJHtlLm1lc3NhZ2V9YCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIChSZSlzaWduIHRoZSBnaXZlbiBhcGsgZmlsZSBvbiB0aGUgbG9jYWwgZmlsZSBzeXN0ZW0gd2l0aCBhIGN1c3RvbSBjZXJ0aWZpY2F0ZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXBrIC0gVGhlIGZ1bGwgcGF0aCB0byB0aGUgbG9jYWwgYXBrIGZpbGUuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgc2lnbmluZyBmYWlscy5cbiAqL1xuYXBrU2lnbmluZ01ldGhvZHMuc2lnbldpdGhDdXN0b21DZXJ0ID0gYXN5bmMgZnVuY3Rpb24gKGFwaykge1xuICBsb2cuZGVidWcoYFNpZ25pbmcgJyR7YXBrfScgd2l0aCBjdXN0b20gY2VydGApO1xuICBpZiAoIShhd2FpdCBmcy5leGlzdHModGhpcy5rZXlzdG9yZVBhdGgpKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgS2V5c3RvcmU6ICR7dGhpcy5rZXlzdG9yZVBhdGh9IGRvZXNuJ3QgZXhpc3QuYCk7XG4gIH1cbiAgaWYgKCEoYXdhaXQgZnMuZXhpc3RzKGFwaykpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAnJHthcGt9JyBkb2Vzbid0IGV4aXN0LmApO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBhcmdzID0gWydzaWduJyxcbiAgICAgICctLWtzJywgdGhpcy5rZXlzdG9yZVBhdGgsXG4gICAgICAnLS1rcy1rZXktYWxpYXMnLCB0aGlzLmtleUFsaWFzLFxuICAgICAgJy0ta3MtcGFzcycsIGBwYXNzOiR7dGhpcy5rZXlzdG9yZVBhc3N3b3JkfWAsXG4gICAgICAnLS1rZXktcGFzcycsIGBwYXNzOiR7dGhpcy5rZXlQYXNzd29yZH1gLFxuICAgICAgYXBrXTtcbiAgICBhd2FpdCB0aGlzLmV4ZWN1dGVBcGtzaWduZXIoYXJncyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGxvZy53YXJuKGBDYW5ub3QgdXNlIGFwa3NpZ25lciB0b29sIGZvciBzaWduaW5nLiBEZWZhdWx0aW5nIHRvIGphcnNpZ25lci4gYCArXG4gICAgICAgICAgICAgYE9yaWdpbmFsIGVycm9yOiAke2Vyci5tZXNzYWdlfWApO1xuICAgIHRyeSB7XG4gICAgICBsb2cuZGVidWcoXCJVbnNpZ25pbmcgYXBrLlwiKTtcbiAgICAgIGF3YWl0IGV4ZWMoZ2V0SmF2YUZvck9zKCksIFsnLWphcicsIHBhdGgucmVzb2x2ZSh0aGlzLmhlbHBlckphclBhdGgsICd1bnNpZ24uamFyJyksIGFwa10pO1xuICAgICAgbG9nLmRlYnVnKFwiU2lnbmluZyBhcGsuXCIpO1xuICAgICAgY29uc3QgamFyc2lnbmVyID0gcGF0aC5yZXNvbHZlKGdldEphdmFIb21lKCksICdiaW4nLCBgamFyc2lnbmVyJHtzeXN0ZW0uaXNXaW5kb3dzKCkgPyAnLmV4ZScgOiAnJ31gKTtcbiAgICAgIGF3YWl0IGV4ZWMoamFyc2lnbmVyLCBbJy1zaWdhbGcnLCAnTUQ1d2l0aFJTQScsICctZGlnZXN0YWxnJywgJ1NIQTEnLFxuICAgICAgICAnLWtleXN0b3JlJywgdGhpcy5rZXlzdG9yZVBhdGgsICctc3RvcmVwYXNzJywgdGhpcy5rZXlzdG9yZVBhc3N3b3JkLFxuICAgICAgICAnLWtleXBhc3MnLCB0aGlzLmtleVBhc3N3b3JkLCBhcGssIHRoaXMua2V5QWxpYXNdKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBzaWduIHdpdGggY3VzdG9tIGNlcnRpZmljYXRlLiBPcmlnaW5hbCBlcnJvciAke2UubWVzc2FnZX1gKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogKFJlKXNpZ24gdGhlIGdpdmVuIGFwayBmaWxlIG9uIHRoZSBsb2NhbCBmaWxlIHN5c3RlbSB3aXRoIGVpdGhlclxuICogY3VzdG9tIG9yIGRlZmF1bHQgY2VydGlmaWNhdGUgYmFzZWQgb24gX3RoaXMudXNlS2V5c3RvcmVfIHByb3BlcnR5IHZhbHVlXG4gKiBhbmQgWmlwLWFsaWducyBpdCBhZnRlciBzaWduaW5nLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcGsgLSBUaGUgZnVsbCBwYXRoIHRvIHRoZSBsb2NhbCBhcGsgZmlsZS5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBzaWduaW5nIGZhaWxzLlxuICovXG5hcGtTaWduaW5nTWV0aG9kcy5zaWduID0gYXN5bmMgZnVuY3Rpb24gKGFwaykge1xuICBsZXQgYXBrc2lnbmVyRm91bmQgPSB0cnVlO1xuICB0cnkge1xuICAgIGF3YWl0IGdldEFwa3NpZ25lckZvck9zKHRoaXMpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBhcGtzaWduZXJGb3VuZCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKGFwa3NpZ25lckZvdW5kKSB7XG4gICAgLy8gaXQgaXMgbmVjZXNzYXJ5IHRvIGFwcGx5IHppcGFsaWduIG9ubHkgYmVmb3JlIHNpZ25pbmdcbiAgICAvLyBpZiBhcGtzaWduZXIgaXMgdXNlZCBvciBvbmx5IGFmdGVyIHNpZ25pbmcgaWYgd2Ugb25seSBoYXZlXG4gICAgLy8gc2lnbi5qYXIgdXRpbGl0eVxuICAgIGF3YWl0IHRoaXMuemlwQWxpZ25BcGsoYXBrKTtcbiAgfVxuXG4gIGlmICh0aGlzLnVzZUtleXN0b3JlKSB7XG4gICAgYXdhaXQgdGhpcy5zaWduV2l0aEN1c3RvbUNlcnQoYXBrKTtcbiAgfSBlbHNlIHtcbiAgICBhd2FpdCB0aGlzLnNpZ25XaXRoRGVmYXVsdENlcnQoYXBrKTtcbiAgfVxuXG4gIGlmICghYXBrc2lnbmVyRm91bmQpIHtcbiAgICBhd2FpdCB0aGlzLnppcEFsaWduQXBrKGFwayk7XG4gIH1cbn07XG5cbi8qKlxuICogUGVyZm9ybSB6aXAtYWxpZ25pbmcgdG8gdGhlIGdpdmVuIGxvY2FsIGFwayBmaWxlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcGsgLSBUaGUgZnVsbCBwYXRoIHRvIHRoZSBsb2NhbCBhcGsgZmlsZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBhcGsgaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IGFsaWduZWRcbiAqIG9yIGZhbHNlIGlmIHRoZSBhcGsgaGFzIGJlZW4gYWxyZWFkeSBhbGlnbmVkLlxuICogQHRocm93cyB7RXJyb3J9IElmIHppcC1hbGlnbiBmYWlscy5cbiAqL1xuYXBrU2lnbmluZ01ldGhvZHMuemlwQWxpZ25BcGsgPSBhc3luYyBmdW5jdGlvbiAoYXBrKSB7XG4gIGF3YWl0IHRoaXMuaW5pdFppcEFsaWduKCk7XG4gIHRyeSB7XG4gICAgYXdhaXQgZXhlYyh0aGlzLmJpbmFyaWVzLnppcGFsaWduLCBbJy1jJywgJzQnLCBhcGtdKTtcbiAgICBsb2cuZGVidWcoYCR7YXBrfScgaXMgYWxyZWFkeSB6aXAtYWxpZ25lZC4gRG9pbmcgbm90aGluZ2ApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZy5kZWJ1ZyhgJyR7YXBrfScgaXMgbm90IHppcC1hbGlnbmVkLiBBbGlnbmluZ2ApO1xuICB9XG4gIGNvbnN0IGFsaWduZWRBcGsgPSBhd2FpdCB0ZW1wRGlyLnBhdGgoe3ByZWZpeDogJ2FwcGl1bScsIHN1ZmZpeDogJy50bXAnfSk7XG4gIGF3YWl0IG1rZGlycChwYXRoLmRpcm5hbWUoYWxpZ25lZEFwaykpO1xuICB0cnkge1xuICAgIGF3YWl0IGV4ZWModGhpcy5iaW5hcmllcy56aXBhbGlnbiwgWyctZicsICc0JywgYXBrLCBhbGlnbmVkQXBrXSk7XG4gICAgYXdhaXQgZnMubXYoYWxpZ25lZEFwaywgYXBrLCB7IG1rZGlycDogdHJ1ZSB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChhd2FpdCBmcy5leGlzdHMoYWxpZ25lZEFwaykpIHtcbiAgICAgIGF3YWl0IGZzLnVubGluayhhbGlnbmVkQXBrKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGB6aXBBbGlnbkFwayBmYWlsZWQuIE9yaWdpbmFsIGVycm9yOiAke2UubWVzc2FnZX0uIFN0ZG91dDogJyR7ZS5zdGRvdXR9JzsgU3RkZXJyOiAnJHtlLnN0ZGVycn0nYCk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGFwcCBpcyBhbHJlYWR5IHNpZ25lZCB3aXRoIHRoZSBkZWZhdWx0IEFwcGl1bSBjZXJpdGZpY2F0ZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXBrIC0gVGhlIGZ1bGwgcGF0aCB0byB0aGUgbG9jYWwgYXBrIGZpbGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGdrIC0gVGhlIG5hbWUgb2YgYXBwbGljYXRpb24gcGFja2FnZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgZ2l2ZW4gYXBwbGljYXRpb24gaXMgYWxyZWFkeSBzaWduZWQuXG4gKi9cbmFwa1NpZ25pbmdNZXRob2RzLmNoZWNrQXBrQ2VydCA9IGFzeW5jIGZ1bmN0aW9uIChhcGssIHBrZykge1xuICBsb2cuZGVidWcoYENoZWNraW5nIGFwcCBjZXJ0IGZvciAke2Fwa31gKTtcbiAgaWYgKCFhd2FpdCBmcy5leGlzdHMoYXBrKSkge1xuICAgIGxvZy5kZWJ1ZyhgJyR7YXBrfScgZG9lc24ndCBleGlzdGApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodGhpcy51c2VLZXlzdG9yZSkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmNoZWNrQ3VzdG9tQXBrQ2VydChhcGssIHBrZyk7XG4gIH1cblxuICBsZXQgdmVyaWZpY2F0aW9uRnVuYztcbiAgdHJ5IHtcbiAgICBhd2FpdCBnZXRBcGtzaWduZXJGb3JPcyh0aGlzKTtcbiAgICB2ZXJpZmljYXRpb25GdW5jID0gYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgdGhpcy5leGVjdXRlQXBrc2lnbmVyKFsndmVyaWZ5JywgJy0tcHJpbnQtY2VydHMnLCBhcGtdKTtcbiAgICAgIGlmICghXy5pbmNsdWRlcyhvdXRwdXQsIERFRkFVTFRfQ0VSVF9ESUdFU1QpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJyR7YXBrfScgaXMgc2lnbmVkIHdpdGggbm9uLWRlZmF1bHQgY2VydGlmaWNhdGVgKTtcbiAgICAgIH1cbiAgICB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nLndhcm4oYENhbm5vdCB1c2UgYXBrc2lnbmVyIHRvb2wgZm9yIHNpZ25hdHVyZSB2ZXJpZmljYXRpb24uIERlZmF1bHRpbmcgdG8gdmVyaWZ5Lmphci4gYCArXG4gICAgICBgT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICAgIGNvbnN0IGphdmEgPSBnZXRKYXZhRm9yT3MoKTtcbiAgICB2ZXJpZmljYXRpb25GdW5jID0gYXN5bmMgKCkgPT4gYXdhaXQgZXhlYyhqYXZhLCBbJy1qYXInLCBwYXRoLnJlc29sdmUodGhpcy5oZWxwZXJKYXJQYXRoLCAndmVyaWZ5LmphcicpLCBhcGtdKTtcbiAgfVxuICB0cnkge1xuICAgIGF3YWl0IHZlcmlmaWNhdGlvbkZ1bmMoKTtcbiAgICBsb2cuZGVidWcoYCcke2Fwa30nIGlzIGFscmVhZHkgc2lnbmVkLmApO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nLmRlYnVnKGAnJHthcGt9JyBpcyBub3Qgc2lnbmVkIHdpdGggZGVidWcgY2VydC5gKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGFwcCBpcyBhbHJlYWR5IHNpZ25lZCB3aXRoIGEgY3VzdG9tIGNlcnRpZmljYXRlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcGsgLSBUaGUgZnVsbCBwYXRoIHRvIHRoZSBsb2NhbCBhcGsgZmlsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwZ2sgLSBUaGUgbmFtZSBvZiBhcHBsaWNhdGlvbiBwYWNrYWdlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBnaXZlbiBhcHBsaWNhdGlvbiBpcyBhbHJlYWR5IHNpZ25lZCB3aXRoIGEgY3VzdG9tIGNlcnRpZmljYXRlLlxuICovXG5hcGtTaWduaW5nTWV0aG9kcy5jaGVja0N1c3RvbUFwa0NlcnQgPSBhc3luYyBmdW5jdGlvbiAoYXBrLCBwa2cpIHtcbiAgbG9nLmRlYnVnKGBDaGVja2luZyBjdXN0b20gYXBwIGNlcnQgZm9yICR7YXBrfWApO1xuICBsZXQgaCA9IFwiYS1mQS1GMC05XCI7XG4gIGxldCBtZDVTdHIgPSBbYC4qTUQ1LiooKD86WyR7aH1dezJ9Oil7MTV9WyR7aH1dezJ9KWBdO1xuICBsZXQgbWQ1ID0gbmV3IFJlZ0V4cChtZDVTdHIsICdtaScpO1xuICBsZXQgamF2YUhvbWUgPSBnZXRKYXZhSG9tZSgpO1xuICBsZXQga2V5dG9vbCA9IHBhdGgucmVzb2x2ZShqYXZhSG9tZSwgJ2JpbicsIGBrZXl0b29sJHtzeXN0ZW0uaXNXaW5kb3dzKCkgPyAnLmV4ZScgOiAnJ31gKTtcbiAgbGV0IGtleXN0b3JlSGFzaCA9IGF3YWl0IHRoaXMuZ2V0S2V5c3RvcmVNZDUoa2V5dG9vbCwgbWQ1KTtcbiAgcmV0dXJuIGF3YWl0IHRoaXMuY2hlY2tBcGtLZXlzdG9yZU1hdGNoKGtleXRvb2wsIG1kNSwga2V5c3RvcmVIYXNoLCBwa2csIGFwayk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgTUQ1IGhhc2ggb2YgdGhlIGtleXN0b3JlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXl0b29sIC0gVGhlIG5hbWUgb2YgdGhlIGtleXRvb2wgdXRpbGl0eS5cbiAqIEBwYXJhbSB7UmVnRXhwfSBtZDVyZSAtIFRoZSBwYXR0ZXJuIHVzZWQgdG8gbWF0Y2ggdGhlIHJlc3VsdCBpbiBfa2V5dG9vbF8gb3V0cHV0LlxuICogQHJldHVybiB7P3N0cmluZ30gS2V5c3RvcmUgTUQ1IGhhc2ggb3IgX251bGxfIGlmIHRoZSBoYXNoIGNhbm5vdCBiZSBwYXJzZWQuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgZ2V0dGluZyBrZXlzdG9yZSBNRDUgaGFzaCBmYWlscy5cbiAqL1xuYXBrU2lnbmluZ01ldGhvZHMuZ2V0S2V5c3RvcmVNZDUgPSBhc3luYyBmdW5jdGlvbiAoa2V5dG9vbCwgbWQ1cmUpIHtcbiAgbG9nLmRlYnVnKFwiUHJpbnRpbmcga2V5c3RvcmUgbWQ1LlwiKTtcbiAgdHJ5IHtcbiAgICBsZXQge3N0ZG91dH0gPSBhd2FpdCBleGVjKGtleXRvb2wsIFsnLXYnLCAnLWxpc3QnLFxuICAgICAgJy1hbGlhcycsIHRoaXMua2V5QWxpYXMsXG4gICAgICAnLWtleXN0b3JlJywgdGhpcy5rZXlzdG9yZVBhdGgsXG4gICAgICAnLXN0b3JlcGFzcycsIHRoaXMua2V5c3RvcmVQYXNzd29yZF0pO1xuICAgIGxldCBrZXlzdG9yZUhhc2ggPSBtZDVyZS5leGVjKHN0ZG91dCk7XG4gICAga2V5c3RvcmVIYXNoID0ga2V5c3RvcmVIYXNoID8ga2V5c3RvcmVIYXNoWzFdIDogbnVsbDtcbiAgICBsb2cuZGVidWcoYEtleXN0b3JlIE1ENTogJHtrZXlzdG9yZUhhc2h9YCk7XG4gICAgcmV0dXJuIGtleXN0b3JlSGFzaDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgZ2V0S2V5c3RvcmVNZDUgZmFpbGVkLiBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIE1ENSBoYXNoIG9mIHRoZSBwYXJ0aWN1bGFyIGFwcGxpY2F0aW9uIG1hdGNoZXMgdG8gdGhlIGdpdmVuIGhhc2guXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleXRvb2wgLSBUaGUgbmFtZSBvZiB0aGUga2V5dG9vbCB1dGlsaXR5LlxuICogQHBhcmFtIHtSZWdFeHB9IG1kNXJlIC0gVGhlIHBhdHRlcm4gdXNlZCB0byBtYXRjaCB0aGUgcmVzdWx0IGluIF9rZXl0b29sXyBvdXRwdXQuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5c3RvcmVIYXNoIC0gVGhlIGV4cGVjdGVkIGhhc2ggdmFsdWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGtnIC0gVGhlIG5hbWUgb2YgdGhlIGluc3RhbGxlZCBwYWNrYWdlLlxuICogQHBhcmFtIHtzdHJpbmd9IGFwayAtIFRoZSBmdWxsIHBhdGggdG8gdGhlIGV4aXN0aW5nIGFwayBmaWxlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBib3RoIGhhc2hlcyBhcmUgZXF1YWwuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgZ2V0dGluZyBrZXlzdG9yZSBNRDUgaGFzaCBmYWlscy5cbiAqL1xuYXBrU2lnbmluZ01ldGhvZHMuY2hlY2tBcGtLZXlzdG9yZU1hdGNoID0gYXN5bmMgZnVuY3Rpb24gKGtleXRvb2wsIG1kNXJlLCBrZXlzdG9yZUhhc2gsXG4gICAgcGtnLCBhcGspIHtcbiAgbGV0IGVudHJ5SGFzaCA9IG51bGw7XG4gIGxldCByc2EgPSAvXk1FVEEtSU5GXFwvLipcXC5bclJdW3NTXVthQV0kLztcbiAgbGV0IGZvdW5kS2V5c3RvcmVNYXRjaCA9IGZhbHNlO1xuXG4gIC8vZm9yIChsZXQgZW50cnkgb2YgZW50cmllcykge1xuICBhd2FpdCB6aXAucmVhZEVudHJpZXMoYXBrLCBhc3luYyAoe2VudHJ5LCBleHRyYWN0RW50cnlUb30pID0+IHtcbiAgICBlbnRyeSA9IGVudHJ5LmZpbGVOYW1lO1xuICAgIGlmICghcnNhLnRlc3QoZW50cnkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxvZy5kZWJ1ZyhgRW50cnk6ICR7ZW50cnl9YCk7XG4gICAgbGV0IGVudHJ5UGF0aCA9IHBhdGguam9pbih0aGlzLnRtcERpciwgcGtnLCAnY2VydCcpO1xuICAgIGxvZy5kZWJ1ZyhgZW50cnlQYXRoOiAke2VudHJ5UGF0aH1gKTtcbiAgICBsZXQgZW50cnlGaWxlID0gcGF0aC5qb2luKGVudHJ5UGF0aCwgZW50cnkpO1xuICAgIGxvZy5kZWJ1ZyhgZW50cnlGaWxlOiAke2VudHJ5RmlsZX1gKTtcbiAgICAvLyBlbnN1cmUgL3RtcC9wa2cvY2VydC8gZG9lc24ndCBleGlzdCBvciBleHRyYWN0IHdpbGwgZmFpbC5cbiAgICBhd2FpdCBmcy5yaW1yYWYoZW50cnlQYXRoKTtcbiAgICAvLyBNRVRBLUlORi9DRVJULlJTQVxuICAgIGF3YWl0IGV4dHJhY3RFbnRyeVRvKGVudHJ5UGF0aCk7XG4gICAgbG9nLmRlYnVnKFwiZXh0cmFjdGVkIVwiKTtcbiAgICAvLyBjaGVjayBmb3IgbWF0Y2hcbiAgICBsb2cuZGVidWcoXCJQcmludGluZyBhcGsgbWQ1LlwiKTtcbiAgICBsZXQge3N0ZG91dH0gPSBhd2FpdCBleGVjKGtleXRvb2wsIFsnLXYnLCAnLXByaW50Y2VydCcsICctZmlsZScsIGVudHJ5RmlsZV0pO1xuICAgIGVudHJ5SGFzaCA9IG1kNXJlLmV4ZWMoc3Rkb3V0KTtcbiAgICBlbnRyeUhhc2ggPSBlbnRyeUhhc2ggPyBlbnRyeUhhc2hbMV0gOiBudWxsO1xuICAgIGxvZy5kZWJ1ZyhgZW50cnlIYXNoIE1ENTogJHtlbnRyeUhhc2h9YCk7XG4gICAgbG9nLmRlYnVnKGBrZXlzdG9yZSBNRDU6ICR7a2V5c3RvcmVIYXNofWApO1xuICAgIGxldCBtYXRjaGVzS2V5c3RvcmUgPSBlbnRyeUhhc2ggJiYgZW50cnlIYXNoID09PSBrZXlzdG9yZUhhc2g7XG4gICAgbG9nLmRlYnVnKGBNYXRjaGVzIGtleXN0b3JlPyAke21hdGNoZXNLZXlzdG9yZX1gKTtcblxuICAgIC8vIElmIHdlIGhhdmUgYSBrZXlzdG9yZSBtYXRjaCwgc3RvcCBpdGVyYXRpbmdcbiAgICBpZiAobWF0Y2hlc0tleXN0b3JlKSB7XG4gICAgICBmb3VuZEtleXN0b3JlTWF0Y2ggPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBmb3VuZEtleXN0b3JlTWF0Y2g7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBhcGtTaWduaW5nTWV0aG9kcztcbiJdLCJzb3VyY2VSb290IjoiLi4vLi4vLi4ifQ==
