'use strict';

var _toConsumableArray = require('babel-runtime/helpers/to-consumable-array')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _loggerJs = require('../logger.js');

var _loggerJs2 = _interopRequireDefault(_loggerJs);

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _appiumSupport = require('appium-support');

var _helpers = require('../helpers');

var _teen_process = require('teen_process');

var _asyncbox = require('asyncbox');

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _shellQuote = require('shell-quote');

var systemCallMethods = {};

var DEFAULT_ADB_EXEC_TIMEOUT = 20000; // in milliseconds
var DEFAULT_ADB_REBOOT_RETRIES = 90;

var LINKER_WARNING_REGEXP = /^WARNING: linker.+$/m;
var PROTOCOL_FAULT_ERROR_REGEXP = new RegExp('protocol fault \\(no status\\)', 'i');
var DEVICE_NOT_FOUND_ERROR_REGEXP = new RegExp('error: device (\'.+\' )?not found', 'i');
var DEVICE_CONNECTING_ERROR_REGEXP = new RegExp('error: device still connecting', 'i');

var CERTS_ROOT = '/system/etc/security/cacerts';

/**
 * Retrieve full path to the given binary.
 *
 * @param {string} binaryName - The name of the binary.
 * @return {string} Full path to the given binary including current SDK root.
 */
systemCallMethods.getSdkBinaryPath = _lodash2['default'].memoize(function callee$0$0(binaryName) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].info('Checking whether ' + binaryName + ' is present');

        if (!this.sdkRoot) {
          context$1$0.next = 5;
          break;
        }

        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.getBinaryFromSdkRoot(binaryName));

      case 4:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 5:
        _loggerJs2['default'].warn('The ANDROID_HOME environment variable is not set to the Android SDK ' + 'root directory path. ANDROID_HOME is required for compatibility ' + ('with SDK 23+. Checking along PATH for ' + binaryName + '.'));
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(this.getBinaryFromPath(binaryName));

      case 8:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 9:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
});

/**
 * Retrieve the name of the tool,
 * which prints full path to the given command shortcut.
 *
 * @return {string} Depending on the current platform this is
 *                  supposed to be either 'which' or 'where'.
 */
systemCallMethods.getCommandForOS = _lodash2['default'].memoize(function () {
  return _appiumSupport.system.isWindows() ? 'where' : 'which';
});

/**
 * Retrieve full binary name for the current operating system.
 *
 * @param {string} binaryName - simple binary name, for example 'android'.
 * @return {string} Formatted binary name depending on the current platform,
 *                  for example, 'android.bat' on Windows.
 */
systemCallMethods.getBinaryNameForOS = _lodash2['default'].memoize(function (binaryName) {
  if (!_appiumSupport.system.isWindows()) {
    return binaryName;
  }

  if (['android', 'apksigner', 'apkanalyzer'].indexOf(binaryName) >= 0 && !binaryName.toLowerCase().endsWith('.bat')) {
    return binaryName + '.bat';
  }
  if (!binaryName.toLowerCase().endsWith('.exe')) {
    return binaryName + '.exe';
  }
  return binaryName;
});

/**
 * Retrieve full path to the given binary.
 *
 * @param {string} binaryName - Simple name of a binary file.
 * @return {string} Full path to the given binary. The method tries
 *                  to enumerate all the known locations where the binary
 *                  might be located and stops the search as soon as the first
 *                  match is found on the local file system.
 * @throws {Error} If the binary with given name is not present at any
 *                 of known locations or Android SDK is not installed on the
 *                 local file system.
 */
systemCallMethods.getBinaryFromSdkRoot = _lodash2['default'].memoize(function callee$0$0(binaryName) {
  var binaryLoc, binaryLocs, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, loc;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        binaryLoc = null;

        binaryName = this.getBinaryNameForOS(binaryName);
        binaryLocs = [_path2['default'].resolve(this.sdkRoot, "platform-tools", binaryName), _path2['default'].resolve(this.sdkRoot, "emulator", binaryName), _path2['default'].resolve(this.sdkRoot, "tools", binaryName), _path2['default'].resolve(this.sdkRoot, "tools", "bin", binaryName)];
        context$1$0.t0 = _lodash2['default'];
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap((0, _helpers.getBuildToolsDirs)(this.sdkRoot));

      case 6:
        context$1$0.t1 = context$1$0.sent;

        context$1$0.t2 = function (dir) {
          return binaryLocs.push(_path2['default'].resolve(dir, binaryName));
        };

        context$1$0.t0.forEach.call(context$1$0.t0, context$1$0.t1, context$1$0.t2);
        _iteratorNormalCompletion = true;
        _didIteratorError = false;
        _iteratorError = undefined;
        context$1$0.prev = 12;
        _iterator = _getIterator(binaryLocs);

      case 14:
        if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
          context$1$0.next = 24;
          break;
        }

        loc = _step.value;
        context$1$0.next = 18;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(loc));

      case 18:
        if (!context$1$0.sent) {
          context$1$0.next = 21;
          break;
        }

        binaryLoc = loc;
        return context$1$0.abrupt('break', 24);

      case 21:
        _iteratorNormalCompletion = true;
        context$1$0.next = 14;
        break;

      case 24:
        context$1$0.next = 30;
        break;

      case 26:
        context$1$0.prev = 26;
        context$1$0.t3 = context$1$0['catch'](12);
        _didIteratorError = true;
        _iteratorError = context$1$0.t3;

      case 30:
        context$1$0.prev = 30;
        context$1$0.prev = 31;

        if (!_iteratorNormalCompletion && _iterator['return']) {
          _iterator['return']();
        }

      case 33:
        context$1$0.prev = 33;

        if (!_didIteratorError) {
          context$1$0.next = 36;
          break;
        }

        throw _iteratorError;

      case 36:
        return context$1$0.finish(33);

      case 37:
        return context$1$0.finish(30);

      case 38:
        if (!_lodash2['default'].isNull(binaryLoc)) {
          context$1$0.next = 40;
          break;
        }

        throw new Error('Could not find ' + binaryName + ' in ' + binaryLocs + '. ' + ('Do you have the Android SDK installed at \'' + this.sdkRoot + '\'?'));

      case 40:
        binaryLoc = binaryLoc.trim();
        _loggerJs2['default'].info('Using ' + binaryName + ' from ' + binaryLoc);
        return context$1$0.abrupt('return', binaryLoc);

      case 43:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[12, 26, 30, 38], [31,, 33, 37]]);
});

/**
 * Retrieve full path to a binary file using the standard system lookup tool.
 *
 * @param {string} binaryName - The name of the binary.
 * @return {string} Full path to the binary received from 'which'/'where'
 *                  output.
 * @throws {Error} If lookup tool returns non-zero return code.
 */
systemCallMethods.getBinaryFromPath = function callee$0$0(binaryName) {
  var binaryLoc, cmd, _ref, stdout;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        binaryLoc = null;
        cmd = this.getCommandForOS();
        context$1$0.prev = 2;
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(cmd, [binaryName]));

      case 5:
        _ref = context$1$0.sent;
        stdout = _ref.stdout;

        _loggerJs2['default'].info('Using ' + binaryName + ' from ' + stdout);
        // TODO write a test for binaries with spaces.
        binaryLoc = stdout.trim();
        return context$1$0.abrupt('return', binaryLoc);

      case 12:
        context$1$0.prev = 12;
        context$1$0.t0 = context$1$0['catch'](2);
        throw new Error('Could not find ' + binaryName + ' Please set the ANDROID_HOME ' + 'environment variable with the Android SDK root directory path.');

      case 15:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[2, 12]]);
};

/**
 * @typedef {Object} Device
 * @property {string} udid - The device udid.
 * @property {string} state - Current device state, as it is visible in
 *                            _adb devices -l_ output.
 */

/**
 * Retrieve the list of devices visible to adb.
 *
 * @return {Array.<Device>} The list of devices or an empty list if
 *                          no devices are connected.
 * @throws {Error} If there was an error while listing devices.
 */
systemCallMethods.getConnectedDevices = function callee$0$0() {
  var _ref2, stdout, startingIndex, devices, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, line, lineInfo;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug("Getting connected devices...");
        context$1$0.prev = 1;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(this.executable.path, this.executable.defaultArgs.concat(['devices'])));

      case 4:
        _ref2 = context$1$0.sent;
        stdout = _ref2.stdout;
        startingIndex = stdout.indexOf("List of devices");

        if (!(startingIndex === -1)) {
          context$1$0.next = 9;
          break;
        }

        throw new Error('Unexpected output while trying to get devices. output was: ' + stdout);

      case 9:
        // slicing ouput we care about.
        stdout = stdout.slice(startingIndex);
        devices = [];
        _iteratorNormalCompletion2 = true;
        _didIteratorError2 = false;
        _iteratorError2 = undefined;
        context$1$0.prev = 14;

        for (_iterator2 = _getIterator(stdout.split("\n")); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          line = _step2.value;

          if (line.trim() !== "" && line.indexOf("List of devices") === -1 && line.indexOf("adb server") === -1 && line.indexOf("* daemon") === -1 && line.indexOf("offline") === -1) {
            lineInfo = line.split("\t");

            // state is either "device" or "offline", afaict
            devices.push({ udid: lineInfo[0], state: lineInfo[1] });
          }
        }
        context$1$0.next = 22;
        break;

      case 18:
        context$1$0.prev = 18;
        context$1$0.t0 = context$1$0['catch'](14);
        _didIteratorError2 = true;
        _iteratorError2 = context$1$0.t0;

      case 22:
        context$1$0.prev = 22;
        context$1$0.prev = 23;

        if (!_iteratorNormalCompletion2 && _iterator2['return']) {
          _iterator2['return']();
        }

      case 25:
        context$1$0.prev = 25;

        if (!_didIteratorError2) {
          context$1$0.next = 28;
          break;
        }

        throw _iteratorError2;

      case 28:
        return context$1$0.finish(25);

      case 29:
        return context$1$0.finish(22);

      case 30:
        _loggerJs2['default'].debug(devices.length + ' device(s) connected');
        return context$1$0.abrupt('return', devices);

      case 34:
        context$1$0.prev = 34;
        context$1$0.t1 = context$1$0['catch'](1);
        throw new Error('Error while getting connected devices. Original error: ' + context$1$0.t1.message);

      case 37:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[1, 34], [14, 18, 22, 30], [23,, 25, 29]]);
};

/**
 * Retrieve the list of devices visible to adb within the given timeout.
 *
 * @param {number} timeoutMs - The maximum number of milliseconds to get at least
 *                             one list item.
 * @return {Array.<Device>} The list of connected devices.
 * @throws {Error} If no connected devices can be detected within the given timeout.
 */
systemCallMethods.getDevicesWithRetry = function callee$0$0() {
  var timeoutMs = arguments.length <= 0 || arguments[0] === undefined ? 20000 : arguments[0];
  var start, getDevices;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        start = Date.now();

        _loggerJs2['default'].debug("Trying to find a connected android device");

        getDevices = function getDevices() {
          var devices;
          return _regeneratorRuntime.async(function getDevices$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                if (!(Date.now() - start > timeoutMs)) {
                  context$2$0.next = 2;
                  break;
                }

                throw new Error("Could not find a connected Android device.");

              case 2:
                context$2$0.prev = 2;
                context$2$0.next = 5;
                return _regeneratorRuntime.awrap(this.getConnectedDevices());

              case 5:
                devices = context$2$0.sent;

                if (!(devices.length < 1)) {
                  context$2$0.next = 15;
                  break;
                }

                _loggerJs2['default'].debug("Could not find devices, restarting adb server...");
                context$2$0.next = 10;
                return _regeneratorRuntime.awrap(this.restartAdb());

              case 10:
                context$2$0.next = 12;
                return _regeneratorRuntime.awrap((0, _asyncbox.sleep)(200));

              case 12:
                context$2$0.next = 14;
                return _regeneratorRuntime.awrap(getDevices());

              case 14:
                return context$2$0.abrupt('return', context$2$0.sent);

              case 15:
                return context$2$0.abrupt('return', devices);

              case 18:
                context$2$0.prev = 18;
                context$2$0.t0 = context$2$0['catch'](2);

                _loggerJs2['default'].debug("Could not find devices, restarting adb server...");
                context$2$0.next = 23;
                return _regeneratorRuntime.awrap(this.restartAdb());

              case 23:
                context$2$0.next = 25;
                return _regeneratorRuntime.awrap((0, _asyncbox.sleep)(200));

              case 25:
                context$2$0.next = 27;
                return _regeneratorRuntime.awrap(getDevices());

              case 27:
                return context$2$0.abrupt('return', context$2$0.sent);

              case 28:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this, [[2, 18]]);
        };

        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(getDevices());

      case 5:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 6:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Restart adb server if _this.suppressKillServer_ property is true.
 */
systemCallMethods.restartAdb = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (!this.suppressKillServer) {
          context$1$0.next = 3;
          break;
        }

        _loggerJs2['default'].debug('Not restarting abd since \'suppressKillServer\' is on');
        return context$1$0.abrupt('return');

      case 3:

        _loggerJs2['default'].debug('Restarting adb');
        context$1$0.prev = 4;
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(this.killServer());

      case 7:
        context$1$0.next = 12;
        break;

      case 9:
        context$1$0.prev = 9;
        context$1$0.t0 = context$1$0['catch'](4);

        _loggerJs2['default'].error("Error killing ADB server, going to see if it's online anyway");

      case 12:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[4, 9]]);
};

/**
 * Kill adb server.
 */
systemCallMethods.killServer = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug('Killing adb server on port ' + this.adbPort);
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(this.executable.path, [].concat(_toConsumableArray(this.executable.defaultArgs), ['kill-server'])));

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Reset Telnet authentication token.
 * @see {@link http://tools.android.com/recent/emulator2516releasenotes} for more details.
 *
 * @returns {boolean} If token reset was successful.
 */
systemCallMethods.resetTelnetAuthToken = _lodash2['default'].memoize(function callee$0$0() {
  var homeFolderPath, dstPath;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        homeFolderPath = process.env[process.platform === 'win32' ? 'USERPROFILE' : 'HOME'];

        if (homeFolderPath) {
          context$1$0.next = 4;
          break;
        }

        _loggerJs2['default'].warn('Cannot find the path to user home folder. Ignoring resetting of emulator\'s telnet authentication token');
        return context$1$0.abrupt('return', false);

      case 4:
        dstPath = _path2['default'].resolve(homeFolderPath, '.emulator_console_auth_token');

        _loggerJs2['default'].debug('Overriding ' + dstPath + ' with an empty string to avoid telnet authentication for emulator commands');
        context$1$0.prev = 6;
        context$1$0.next = 9;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.writeFile(dstPath, ''));

      case 9:
        context$1$0.next = 15;
        break;

      case 11:
        context$1$0.prev = 11;
        context$1$0.t0 = context$1$0['catch'](6);

        _loggerJs2['default'].warn('Error ' + context$1$0.t0.message + ' while resetting the content of ' + dstPath + '. Ignoring resetting of emulator\'s telnet authentication token');
        return context$1$0.abrupt('return', false);

      case 15:
        return context$1$0.abrupt('return', true);

      case 16:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[6, 11]]);
});

/**
 * Execute the given emulator command using _adb emu_ tool.
 *
 * @param {Array.<string>} cmd - The array of rest command line parameters.
 */
systemCallMethods.adbExecEmu = function callee$0$0(cmd) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.verifyEmulatorConnected());

      case 2:
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.resetTelnetAuthToken());

      case 4:
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(this.adbExec(['emu'].concat(_toConsumableArray(cmd))));

      case 6:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Execute the given adb command.
 *
 * @param {Array.<string>} cmd - The array of rest command line parameters
 *                      or a single string parameter.
 * @param {Object} opts - Additional options mapping. See
 *                        {@link https://github.com/appium/node-teen_process}
 *                        for more details.
 * @return {string} - Command's stdout.
 * @throws {Error} If the command returned non-zero exit code.
 */
systemCallMethods.adbExec = function callee$0$0(cmd) {
  var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
  var execFunc;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this2 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (cmd) {
          context$1$0.next = 2;
          break;
        }

        throw new Error("You need to pass in a command to adbExec()");

      case 2:
        // setting default timeout for each command to prevent infinite wait.
        opts.timeout = opts.timeout || this.execTimeout || DEFAULT_ADB_EXEC_TIMEOUT;

        execFunc = function execFunc() {
          var args, _ref3, stdout, errText, protocolFaultError, deviceNotFoundError, deviceConnectingError;

          return _regeneratorRuntime.async(function execFunc$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.prev = 0;

                if (!(cmd instanceof Array)) {
                  cmd = [cmd];
                }
                args = this.executable.defaultArgs.concat(cmd);

                _loggerJs2['default'].debug('Running \'' + this.executable.path + ' ' + (0, _shellQuote.quote)(args) + '\'');
                context$2$0.next = 6;
                return _regeneratorRuntime.awrap((0, _teen_process.exec)(this.executable.path, args, opts));

              case 6:
                _ref3 = context$2$0.sent;
                stdout = _ref3.stdout;

                // sometimes ADB prints out weird stdout warnings that we don't want
                // to include in any of the response data, so let's strip it out
                stdout = stdout.replace(LINKER_WARNING_REGEXP, '').trim();
                return context$2$0.abrupt('return', stdout);

              case 12:
                context$2$0.prev = 12;
                context$2$0.t0 = context$2$0['catch'](0);
                errText = context$2$0.t0.message + ', ' + context$2$0.t0.stdout + ', ' + context$2$0.t0.stderr;
                protocolFaultError = PROTOCOL_FAULT_ERROR_REGEXP.test(errText);
                deviceNotFoundError = DEVICE_NOT_FOUND_ERROR_REGEXP.test(errText);
                deviceConnectingError = DEVICE_CONNECTING_ERROR_REGEXP.test(errText);

                if (!(protocolFaultError || deviceNotFoundError || deviceConnectingError)) {
                  context$2$0.next = 24;
                  break;
                }

                _loggerJs2['default'].info('Error sending command, reconnecting device and retrying: ' + cmd);
                context$2$0.next = 22;
                return _regeneratorRuntime.awrap((0, _asyncbox.sleep)(1000));

              case 22:
                context$2$0.next = 24;
                return _regeneratorRuntime.awrap(this.getDevicesWithRetry());

              case 24:
                if (!(context$2$0.t0.code === 0 && context$2$0.t0.stdout)) {
                  context$2$0.next = 28;
                  break;
                }

                stdout = context$2$0.t0.stdout;

                stdout = stdout.replace(LINKER_WARNING_REGEXP, '').trim();
                return context$2$0.abrupt('return', stdout);

              case 28:
                throw new Error('Error executing adbExec. Original error: \'' + context$2$0.t0.message + '\'; ' + ('Stderr: \'' + (context$2$0.t0.stderr || '').trim() + '\'; Code: \'' + context$2$0.t0.code + '\''));

              case 29:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this2, [[0, 12]]);
        };

        context$1$0.next = 6;
        return _regeneratorRuntime.awrap((0, _asyncbox.retry)(2, execFunc));

      case 6:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 7:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Execute the given command using _adb shell_ prefix.
 *
 * @param {Array.<string>|string} cmd - The array of rest command line parameters or a single
 *                                      string parameter.
 * @param {Object} opts - Additional options mapping. See
 *                        {@link https://github.com/appium/node-teen_process}
 *                        for more details.
 * @return {string} - Command's stdout.
 * @throws {Error} If the command returned non-zero exit code.
 */
systemCallMethods.shell = function callee$0$0(cmd) {
  var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.adbExec(_lodash2['default'].isArray(cmd) ? ['shell'].concat(_toConsumableArray(cmd)) : ['shell', cmd], opts));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

systemCallMethods.createSubProcess = function () {
  var args = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];

  // add the default arguments
  args = this.executable.defaultArgs.concat(args);
  _loggerJs2['default'].debug('Creating ADB subprocess with args: ' + JSON.stringify(args));
  return new _teen_process.SubProcess(this.getAdbPath(), args);
};

/**
 * Retrieve the current adb port.
 * @todo can probably deprecate this now that the logic is just to read this.adbPort
 * @return {number} The current adb port number.
 */
systemCallMethods.getAdbServerPort = function () {
  return this.adbPort;
};

/**
 * Retrieve the current emulator port from _adb devives_ output.
 *
 * @return {number} The current emulator port.
 * @throws {Error} If there are no connected devices.
 */
systemCallMethods.getEmulatorPort = function callee$0$0() {
  var devices, port;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug("Getting running emulator port");

        if (!(this.emulatorPort !== null)) {
          context$1$0.next = 3;
          break;
        }

        return context$1$0.abrupt('return', this.emulatorPort);

      case 3:
        context$1$0.prev = 3;
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(this.getConnectedDevices());

      case 6:
        devices = context$1$0.sent;
        port = this.getPortFromEmulatorString(devices[0].udid);

        if (!port) {
          context$1$0.next = 12;
          break;
        }

        return context$1$0.abrupt('return', port);

      case 12:
        throw new Error('Emulator port not found');

      case 13:
        context$1$0.next = 18;
        break;

      case 15:
        context$1$0.prev = 15;
        context$1$0.t0 = context$1$0['catch'](3);
        throw new Error('No devices connected. Original error: ' + context$1$0.t0.message);

      case 18:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[3, 15]]);
};

/**
 * Retrieve the current emulator port by parsing emulator name string.
 *
 * @param {string} emStr - Emulator name string.
 * @return {number|boolean} Either the current emulator port or
 *                          _false_ if port number cannot be parsed.
 */
systemCallMethods.getPortFromEmulatorString = function (emStr) {
  var portPattern = /emulator-(\d+)/;
  if (portPattern.test(emStr)) {
    return parseInt(portPattern.exec(emStr)[1], 10);
  }
  return false;
};

/**
 * Retrieve the list of currently connected emulators.
 *
 * @return {Array.<Device>} The list of connected devices.
 */
systemCallMethods.getConnectedEmulators = function callee$0$0() {
  var devices, emulators, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, device, port;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;

        _loggerJs2['default'].debug("Getting connected emulators");
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.getConnectedDevices());

      case 4:
        devices = context$1$0.sent;
        emulators = [];
        _iteratorNormalCompletion3 = true;
        _didIteratorError3 = false;
        _iteratorError3 = undefined;
        context$1$0.prev = 9;

        for (_iterator3 = _getIterator(devices); !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          device = _step3.value;
          port = this.getPortFromEmulatorString(device.udid);

          if (port) {
            device.port = port;
            emulators.push(device);
          }
        }
        context$1$0.next = 17;
        break;

      case 13:
        context$1$0.prev = 13;
        context$1$0.t0 = context$1$0['catch'](9);
        _didIteratorError3 = true;
        _iteratorError3 = context$1$0.t0;

      case 17:
        context$1$0.prev = 17;
        context$1$0.prev = 18;

        if (!_iteratorNormalCompletion3 && _iterator3['return']) {
          _iterator3['return']();
        }

      case 20:
        context$1$0.prev = 20;

        if (!_didIteratorError3) {
          context$1$0.next = 23;
          break;
        }

        throw _iteratorError3;

      case 23:
        return context$1$0.finish(20);

      case 24:
        return context$1$0.finish(17);

      case 25:
        _loggerJs2['default'].debug(emulators.length + ' emulator(s) connected');
        return context$1$0.abrupt('return', emulators);

      case 29:
        context$1$0.prev = 29;
        context$1$0.t1 = context$1$0['catch'](0);
        throw new Error('Error getting emulators. Original error: ' + context$1$0.t1.message);

      case 32:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 29], [9, 13, 17, 25], [18,, 20, 24]]);
};

/**
 * Set _emulatorPort_ property of the current class.
 *
 * @param {number} emPort - The emulator port to be set.
 */
systemCallMethods.setEmulatorPort = function (emPort) {
  this.emulatorPort = emPort;
};

/**
 * Set the identifier of the current device (_this.curDeviceId_).
 *
 * @param {string} - The device identifier.
 */
systemCallMethods.setDeviceId = function (deviceId) {
  _loggerJs2['default'].debug('Setting device id to ' + deviceId);
  this.curDeviceId = deviceId;
  var argsHasDevice = this.executable.defaultArgs.indexOf('-s');
  if (argsHasDevice !== -1) {
    // remove the old device id from the arguments
    this.executable.defaultArgs.splice(argsHasDevice, 2);
  }
  this.executable.defaultArgs.push('-s', deviceId);
};

/**
 * Set the the current device object.
 *
 * @param {Device} deviceObj - The device object to be set.
 */
systemCallMethods.setDevice = function (deviceObj) {
  var deviceId = deviceObj.udid;
  var emPort = this.getPortFromEmulatorString(deviceId);
  this.setEmulatorPort(emPort);
  this.setDeviceId(deviceId);
};

/**
 * Get the object for the currently running emulator.
 *
 * @param {string} avdName - Emulator name.
 * @return {?Device} Currently running emulator or _null_.
 */
systemCallMethods.getRunningAVD = function callee$0$0(avdName) {
  var emulators, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, emulator, runningAVDName;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;

        _loggerJs2['default'].debug('Trying to find ' + avdName + ' emulator');
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.getConnectedEmulators());

      case 4:
        emulators = context$1$0.sent;
        _iteratorNormalCompletion4 = true;
        _didIteratorError4 = false;
        _iteratorError4 = undefined;
        context$1$0.prev = 8;
        _iterator4 = _getIterator(emulators);

      case 10:
        if (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {
          context$1$0.next = 23;
          break;
        }

        emulator = _step4.value;

        this.setEmulatorPort(emulator.port);
        context$1$0.next = 15;
        return _regeneratorRuntime.awrap(this.sendTelnetCommand("avd name"));

      case 15:
        runningAVDName = context$1$0.sent;

        if (!(avdName === runningAVDName)) {
          context$1$0.next = 20;
          break;
        }

        _loggerJs2['default'].debug('Found emulator ' + avdName + ' in port ' + emulator.port);
        this.setDeviceId(emulator.udid);
        return context$1$0.abrupt('return', emulator);

      case 20:
        _iteratorNormalCompletion4 = true;
        context$1$0.next = 10;
        break;

      case 23:
        context$1$0.next = 29;
        break;

      case 25:
        context$1$0.prev = 25;
        context$1$0.t0 = context$1$0['catch'](8);
        _didIteratorError4 = true;
        _iteratorError4 = context$1$0.t0;

      case 29:
        context$1$0.prev = 29;
        context$1$0.prev = 30;

        if (!_iteratorNormalCompletion4 && _iterator4['return']) {
          _iterator4['return']();
        }

      case 32:
        context$1$0.prev = 32;

        if (!_didIteratorError4) {
          context$1$0.next = 35;
          break;
        }

        throw _iteratorError4;

      case 35:
        return context$1$0.finish(32);

      case 36:
        return context$1$0.finish(29);

      case 37:
        _loggerJs2['default'].debug('Emulator ' + avdName + ' not running');
        return context$1$0.abrupt('return', null);

      case 41:
        context$1$0.prev = 41;
        context$1$0.t1 = context$1$0['catch'](0);
        throw new Error('Error getting AVD. Original error: ' + context$1$0.t1.message);

      case 44:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 41], [8, 25, 29, 37], [30,, 32, 36]]);
};

/**
 * Get the object for the currently running emulator.
 *
 * @param {string} avdName - Emulator name.
 * @param {number} timeoutMs [20000] - The maximum number of milliseconds
 *                                     to wait until at least one running AVD object
 *                                     is detected.
 * @return {?Device} Currently running emulator or _null_.
 * @throws {Error} If no device has been detected within the timeout.
 */
systemCallMethods.getRunningAVDWithRetry = function callee$0$0(avdName) {
  var timeoutMs = arguments.length <= 1 || arguments[1] === undefined ? 20000 : arguments[1];
  var runningAvd;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this3 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        runningAvd = undefined;
        context$1$0.prev = 1;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap((0, _asyncbox.waitForCondition)(function callee$1$0() {
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.next = 2;
                return _regeneratorRuntime.awrap(this.getRunningAVD(avdName.replace('@', '')));

              case 2:
                runningAvd = context$2$0.sent;
                return context$2$0.abrupt('return', runningAvd);

              case 4:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this3);
        }, {
          waitMs: timeoutMs,
          intervalMs: 200
        }));

      case 4:
        context$1$0.next = 9;
        break;

      case 6:
        context$1$0.prev = 6;
        context$1$0.t0 = context$1$0['catch'](1);
        throw new Error('Error getting AVD with retry. Original error: ' + context$1$0.t0.message);

      case 9:
        return context$1$0.abrupt('return', runningAvd);

      case 10:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[1, 6]]);
};

/**
 * Shutdown all running emulators by killing their processes.
 *
 * @throws {Error} If killing tool returned non-zero return code.
 */
systemCallMethods.killAllEmulators = function callee$0$0() {
  var cmd, args;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        cmd = undefined, args = undefined;

        if (_appiumSupport.system.isWindows()) {
          cmd = 'TASKKILL';
          args = ['TASKKILL', '/IM', 'emulator.exe'];
        } else {
          cmd = '/usr/bin/killall';
          args = ['-m', 'emulator*'];
        }
        context$1$0.prev = 2;
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(cmd, args));

      case 5:
        context$1$0.next = 10;
        break;

      case 7:
        context$1$0.prev = 7;
        context$1$0.t0 = context$1$0['catch'](2);
        throw new Error('Error killing emulators. Original error: ' + context$1$0.t0.message);

      case 10:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[2, 7]]);
};

/**
 * Kill emulator with the given name. No error
 * is thrown is given avd does not exist/is not running.
 *
 * @param {?string} avdName - The name of the emulator to be killed. If empty,
 *                            the current emulator will be killed.
 * @param {?number} timeout [60000] - The amount of time to wait before throwing
 *                                    an exception about unsuccessful killing
 * @return {boolean} - True if the emulator was killed, false otherwise.
 * @throws {Error} if there was a failure by killing the emulator
 */
systemCallMethods.killEmulator = function callee$0$0() {
  var avdName = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
  var timeout = arguments.length <= 1 || arguments[1] === undefined ? 60000 : arguments[1];
  var device;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this4 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (!_appiumSupport.util.hasValue(avdName)) {
          context$1$0.next = 10;
          break;
        }

        _loggerJs2['default'].debug('Killing avd \'' + avdName + '\'');
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.getRunningAVD(avdName));

      case 4:
        device = context$1$0.sent;

        if (device) {
          context$1$0.next = 8;
          break;
        }

        _loggerJs2['default'].info('No avd with name \'' + avdName + '\' running. Skipping kill step.');
        return context$1$0.abrupt('return', false);

      case 8:
        context$1$0.next = 16;
        break;

      case 10:
        // killing the current avd
        _loggerJs2['default'].debug('Killing avd with id \'' + this.curDeviceId + '\'');
        context$1$0.next = 13;
        return _regeneratorRuntime.awrap(this.isEmulatorConnected());

      case 13:
        if (context$1$0.sent) {
          context$1$0.next = 16;
          break;
        }

        _loggerJs2['default'].debug('Emulator with id \'' + this.curDeviceId + '\' not connected. Skipping kill step');
        return context$1$0.abrupt('return', false);

      case 16:
        context$1$0.next = 18;
        return _regeneratorRuntime.awrap(this.adbExec(['emu', 'kill']));

      case 18:
        _loggerJs2['default'].debug('Waiting up to ' + timeout + 'ms until the emulator \'' + (avdName ? avdName : this.curDeviceId) + '\' is killed');
        context$1$0.prev = 19;
        context$1$0.next = 22;
        return _regeneratorRuntime.awrap((0, _asyncbox.waitForCondition)(function callee$1$0() {
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.prev = 0;

                if (!_appiumSupport.util.hasValue(avdName)) {
                  context$2$0.next = 7;
                  break;
                }

                context$2$0.next = 4;
                return _regeneratorRuntime.awrap(this.getRunningAVD(avdName));

              case 4:
                context$2$0.t0 = !context$2$0.sent;
                context$2$0.next = 10;
                break;

              case 7:
                context$2$0.next = 9;
                return _regeneratorRuntime.awrap(this.isEmulatorConnected());

              case 9:
                context$2$0.t0 = !context$2$0.sent;

              case 10:
                return context$2$0.abrupt('return', context$2$0.t0);

              case 13:
                context$2$0.prev = 13;
                context$2$0.t1 = context$2$0['catch'](0);

              case 15:
                return context$2$0.abrupt('return', false);

              case 16:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this4, [[0, 13]]);
        }, {
          waitMs: timeout,
          intervalMs: 2000
        }));

      case 22:
        context$1$0.next = 27;
        break;

      case 24:
        context$1$0.prev = 24;
        context$1$0.t0 = context$1$0['catch'](19);
        throw new Error('The emulator \'' + (avdName ? avdName : this.curDeviceId) + '\' is still running after being killed ' + timeout + 'ms ago');

      case 27:
        _loggerJs2['default'].info('Successfully killed the \'' + (avdName ? avdName : this.curDeviceId) + '\' emulator');
        return context$1$0.abrupt('return', true);

      case 29:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[19, 24]]);
};

/**
 * Start an emulator with given parameters and wait until it is full started.
 *
 * @param {string} avdName - The name of an existing emulator.
 * @param {Array.<string>|string} avdArgs - Additional emulator command line argument.
 * @param {?string} language - Emulator system language.
 * @param {?contry} country - Emulator system country.
 * @param {number} avdLaunchTimeout [60000] - Emulator startup timeout in milliseconds.
 * @param {number} retryTimes [1] - The maximum number of startup retries.
 * @throws {Error} If the emulator fails to start within the given timeout.
 */
systemCallMethods.launchAVD = function callee$0$0(avdName, avdArgs, language, country) {
  var avdLaunchTimeout = arguments.length <= 4 || arguments[4] === undefined ? 60000 : arguments[4];
  var avdReadyTimeout = arguments.length <= 5 || arguments[5] === undefined ? 60000 : arguments[5];
  var retryTimes = arguments.length <= 6 || arguments[6] === undefined ? 1 : arguments[6];
  var emulatorBinaryPath, launchArgs, locale, proc;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug('Launching Emulator with AVD ' + avdName + ', launchTimeout ' + (avdLaunchTimeout + 'ms and readyTimeout ' + avdReadyTimeout + 'ms'));
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.getSdkBinaryPath("emulator"));

      case 3:
        emulatorBinaryPath = context$1$0.sent;

        if (avdName[0] === "@") {
          avdName = avdName.substr(1);
        }
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(this.checkAvdExist(avdName));

      case 7:
        launchArgs = ["-avd", avdName];

        if (_lodash2['default'].isString(language)) {
          _loggerJs2['default'].debug('Setting Android Device Language to ' + language);
          launchArgs.push("-prop", 'persist.sys.language=' + language.toLowerCase());
        }
        if (_lodash2['default'].isString(country)) {
          _loggerJs2['default'].debug('Setting Android Device Country to ' + country);
          launchArgs.push("-prop", 'persist.sys.country=' + country.toUpperCase());
        }
        locale = undefined;

        if (_lodash2['default'].isString(language) && _lodash2['default'].isString(country)) {
          locale = language.toLowerCase() + "-" + country.toUpperCase();
        } else if (_lodash2['default'].isString(language)) {
          locale = language.toLowerCase();
        } else if (_lodash2['default'].isString(country)) {
          locale = country;
        }
        if (_lodash2['default'].isString(locale)) {
          _loggerJs2['default'].debug('Setting Android Device Locale to ' + locale);
          launchArgs.push("-prop", 'persist.sys.locale=' + locale);
        }
        if (!_lodash2['default'].isEmpty(avdArgs)) {
          launchArgs.push.apply(launchArgs, _toConsumableArray(_lodash2['default'].isArray(avdArgs) ? avdArgs : avdArgs.split(' ')));
        }
        _loggerJs2['default'].debug('Running \'' + emulatorBinaryPath + '\' with args: ' + JSON.stringify(launchArgs));
        proc = new _teen_process.SubProcess(emulatorBinaryPath, launchArgs);
        context$1$0.next = 18;
        return _regeneratorRuntime.awrap(proc.start(0));

      case 18:
        proc.on('output', function (stdout, stderr) {
          var _iteratorNormalCompletion5 = true;
          var _didIteratorError5 = false;
          var _iteratorError5 = undefined;

          try {
            for (var _iterator5 = _getIterator((stdout || stderr || '').split('\n').filter(Boolean)), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
              var line = _step5.value;

              _loggerJs2['default'].info('[AVD OUTPUT] ' + line);
            }
          } catch (err) {
            _didIteratorError5 = true;
            _iteratorError5 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion5 && _iterator5['return']) {
                _iterator5['return']();
              }
            } finally {
              if (_didIteratorError5) {
                throw _iteratorError5;
              }
            }
          }
        });
        proc.on('die', function (code, signal) {
          _loggerJs2['default'].warn('Emulator avd ' + avdName + ' exited with code ' + code + (signal ? ', signal ' + signal : ''));
        });
        context$1$0.next = 22;
        return _regeneratorRuntime.awrap((0, _asyncbox.retry)(retryTimes, this.getRunningAVDWithRetry.bind(this), avdName, avdLaunchTimeout));

      case 22:
        context$1$0.next = 24;
        return _regeneratorRuntime.awrap(this.waitForEmulatorReady(avdReadyTimeout));

      case 24:
        return context$1$0.abrupt('return', proc);

      case 25:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * @typedef {Object} ADBVersion
 * @property {string} versionString - ADB version as a string.
 * @property {float} versionFloat - Version number as float value (useful for comparison).
 * @property {number} major - Major version number.
 * @property {number} minor - Minor version number.
 * @property {number} patch - Patch version number.
 */

/**
 * Get the adb version. The result of this method is cached.
 *
 * @return {ADBVersion} The current adb version.
 * @throws {Error} If it is not possible to parse adb version.
 */
systemCallMethods.getAdbVersion = _lodash2['default'].memoize(function callee$0$0() {
  var adbVersion, parts;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.adbExec('version'));

      case 3:
        adbVersion = context$1$0.sent.replace(/Android\sDebug\sBridge\sversion\s([\d\.]*)[\s\w\-]*/, "$1");
        parts = adbVersion.split('.');
        return context$1$0.abrupt('return', {
          versionString: adbVersion,
          versionFloat: parseFloat(adbVersion),
          major: parseInt(parts[0], 10),
          minor: parseInt(parts[1], 10),
          patch: parts[2] ? parseInt(parts[2], 10) : undefined
        });

      case 8:
        context$1$0.prev = 8;
        context$1$0.t0 = context$1$0['catch'](0);
        throw new Error('Error getting adb version. Original error: \'' + context$1$0.t0.message + '\'; ' + ('Stderr: \'' + (context$1$0.t0.stderr || '').trim() + '\'; Code: \'' + context$1$0.t0.code + '\''));

      case 11:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 8]]);
});

/**
 * Check if given emulator exists in the list of available avds.
 *
 * @param {string} avdName - The name of emulator to verify for existence.
 * @throws {Error} If the emulator with given name does not exist.
 */
systemCallMethods.checkAvdExist = function callee$0$0(avdName) {
  var cmd, result, unknownOptionError, sdkVersion, binaryName, existings;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        cmd = undefined, result = undefined;
        context$1$0.prev = 1;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.getSdkBinaryPath('emulator'));

      case 4:
        cmd = context$1$0.sent;
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(cmd, ['-list-avds']));

      case 7:
        result = context$1$0.sent;
        context$1$0.next = 26;
        break;

      case 10:
        context$1$0.prev = 10;
        context$1$0.t0 = context$1$0['catch'](1);
        unknownOptionError = new RegExp("unknown option: -list-avds", "i").test(context$1$0.t0.stderr);

        if (unknownOptionError) {
          context$1$0.next = 15;
          break;
        }

        throw new Error('Error executing checkAvdExist. Original error: \'' + context$1$0.t0.message + '\'; ' + ('Stderr: \'' + (context$1$0.t0.stderr || '').trim() + '\'; Code: \'' + context$1$0.t0.code + '\''));

      case 15:
        context$1$0.next = 17;
        return _regeneratorRuntime.awrap((0, _helpers.getSdkToolsVersion)());

      case 17:
        sdkVersion = context$1$0.sent;
        binaryName = 'android';

        if (sdkVersion) {
          if (sdkVersion.major >= 25) {
            binaryName = 'avdmanager';
          }
        } else {
          _loggerJs2['default'].warn('Defaulting binary name to \'' + binaryName + '\', because SDK version cannot be parsed');
        }
        // If -list-avds option is not available, use android command as an alternative
        context$1$0.next = 22;
        return _regeneratorRuntime.awrap(this.getSdkBinaryPath(binaryName));

      case 22:
        cmd = context$1$0.sent;
        context$1$0.next = 25;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(cmd, ['list', 'avd', '-c']));

      case 25:
        result = context$1$0.sent;

      case 26:
        if (!(result.stdout.indexOf(avdName) === -1)) {
          context$1$0.next = 29;
          break;
        }

        existings = '(' + result.stdout.trim().replace(/[\n]/g, '), (') + ')';
        throw new Error('Avd \'' + avdName + '\' is not available. please select your avd name from one of these: \'' + existings + '\'');

      case 29:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[1, 10]]);
};

/**
 * Check if the current emulator is ready to accept further commands (booting completed).
 *
 * @param {number} timeoutMs [20000] - The maximum number of milliseconds to wait.
 * @throws {Error} If the emulator is not ready within the given timeout.
 */
systemCallMethods.waitForEmulatorReady = function callee$0$0() {
  var timeoutMs = arguments.length <= 0 || arguments[0] === undefined ? 20000 : arguments[0];
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this5 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap((0, _asyncbox.waitForCondition)(function callee$1$0() {
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.prev = 0;
                context$2$0.next = 3;
                return _regeneratorRuntime.awrap(this.shell(['getprop', 'init.svc.bootanim']));

              case 3:
                if (context$2$0.sent.includes('stopped')) {
                  context$2$0.next = 5;
                  break;
                }

                return context$2$0.abrupt('return', false);

              case 5:
                context$2$0.t0 = /\d+\[\w+\]/;
                context$2$0.next = 8;
                return _regeneratorRuntime.awrap(this.shell(['pm', 'get-install-location']));

              case 8:
                context$2$0.t1 = context$2$0.sent;
                return context$2$0.abrupt('return', context$2$0.t0.test.call(context$2$0.t0, context$2$0.t1));

              case 12:
                context$2$0.prev = 12;
                context$2$0.t2 = context$2$0['catch'](0);

                _loggerJs2['default'].debug('Waiting for emulator startup. Intermediate error: ' + context$2$0.t2.message);
                return context$2$0.abrupt('return', false);

              case 16:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this5, [[0, 12]]);
        }, {
          waitMs: timeoutMs,
          intervalMs: 3000
        }));

      case 3:
        context$1$0.next = 8;
        break;

      case 5:
        context$1$0.prev = 5;
        context$1$0.t0 = context$1$0['catch'](0);
        throw new Error('Emulator is not ready within ' + timeoutMs + 'ms');

      case 8:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 5]]);
};

/**
 * Check if the current device is ready to accept further commands (booting completed).
 *
 * @param {number} appDeviceReadyTimeout [30] - The maximum number of seconds to wait.
 * @throws {Error} If the device is not ready within the given timeout.
 */
systemCallMethods.waitForDevice = function callee$0$0() {
  var appDeviceReadyTimeout = arguments.length <= 0 || arguments[0] === undefined ? 30 : arguments[0];
  var retries, timeout;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this6 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        this.appDeviceReadyTimeout = appDeviceReadyTimeout;
        retries = 3;
        timeout = parseInt(this.appDeviceReadyTimeout, 10) / retries * 1000;
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap((0, _asyncbox.retry)(retries, function callee$1$0() {
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.prev = 0;
                context$2$0.next = 3;
                return _regeneratorRuntime.awrap(this.adbExec('wait-for-device', { timeout: timeout }));

              case 3:
                context$2$0.next = 5;
                return _regeneratorRuntime.awrap(this.ping());

              case 5:
                context$2$0.next = 14;
                break;

              case 7:
                context$2$0.prev = 7;
                context$2$0.t0 = context$2$0['catch'](0);
                context$2$0.next = 11;
                return _regeneratorRuntime.awrap(this.restartAdb());

              case 11:
                context$2$0.next = 13;
                return _regeneratorRuntime.awrap(this.getConnectedDevices());

              case 13:
                throw new Error('Error in waiting for device. Original error: \'' + context$2$0.t0.message + '\'. ' + 'Retrying by restarting ADB');

              case 14:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this6, [[0, 7]]);
        }));

      case 5:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Reboot the current device and wait until it is completed.
 *
 * @param {number} retries [DEFAULT_ADB_REBOOT_RETRIES] - The maximum number of reboot retries.
 * @throws {Error} If the device failed to reboot and number of retries is exceeded.
 */
systemCallMethods.reboot = function callee$0$0() {
  var retries = arguments.length <= 0 || arguments[0] === undefined ? DEFAULT_ADB_REBOOT_RETRIES : arguments[0];
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this7 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.prev = 1;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.shell(['stop']));

      case 4:
        context$1$0.next = 15;
        break;

      case 6:
        context$1$0.prev = 6;
        context$1$0.t0 = context$1$0['catch'](1);

        if (!(context$1$0.t0.message.indexOf('must be root') === -1)) {
          context$1$0.next = 10;
          break;
        }

        throw context$1$0.t0;

      case 10:
        // this device needs adb to be running as root to stop.
        // so try to restart the daemon
        _loggerJs2['default'].debug('Device requires adb to be running as root in order to reboot. Restarting daemon');
        context$1$0.next = 13;
        return _regeneratorRuntime.awrap(this.root());

      case 13:
        context$1$0.next = 15;
        return _regeneratorRuntime.awrap(this.shell(['stop']));

      case 15:
        context$1$0.next = 17;
        return _regeneratorRuntime.awrap(_bluebird2['default'].delay(2000));

      case 17:
        context$1$0.next = 19;
        return _regeneratorRuntime.awrap(this.setDeviceProperty('sys.boot_completed', 0));

      case 19:
        context$1$0.next = 21;
        return _regeneratorRuntime.awrap(this.shell(['start']));

      case 21:
        context$1$0.next = 23;
        return _regeneratorRuntime.awrap((0, _asyncbox.retryInterval)(retries, 1000, function callee$1$0() {
          var booted, msg;
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.next = 2;
                return _regeneratorRuntime.awrap(this.getDeviceProperty('sys.boot_completed'));

              case 2:
                booted = context$2$0.sent;

                if (!(booted === '1')) {
                  context$2$0.next = 7;
                  break;
                }

                return context$2$0.abrupt('return');

              case 7:
                msg = 'Waiting for reboot. This takes time';

                _loggerJs2['default'].debug(msg);
                throw new Error(msg);

              case 10:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this7);
        }));

      case 23:
        context$1$0.prev = 23;
        context$1$0.next = 26;
        return _regeneratorRuntime.awrap(this.unroot());

      case 26:
        return context$1$0.finish(23);

      case 27:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0,, 23, 27], [1, 6]]);
};

/**
 * Switch adb server to root mode.
 *
 * @return {boolean} True of the switch was successful or false
 *                   if the switch failed.
 */
systemCallMethods.root = function callee$0$0() {
  var _ref4, stdout;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(this.executable.path, ['root']));

      case 3:
        _ref4 = context$1$0.sent;
        stdout = _ref4.stdout;

        if (!(stdout && stdout.indexOf('adbd cannot run as root') !== -1)) {
          context$1$0.next = 7;
          break;
        }

        throw new Error(stdout.trim());

      case 7:
        return context$1$0.abrupt('return', true);

      case 10:
        context$1$0.prev = 10;
        context$1$0.t0 = context$1$0['catch'](0);

        _loggerJs2['default'].warn('Unable to root adb daemon: \'' + context$1$0.t0.message + '\'. Continuing');
        return context$1$0.abrupt('return', false);

      case 14:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 10]]);
};

/**
 * Switch adb server to non-root mode.
 *
 * @return {boolean} True of the switch was successful or false
 *                   if the switch failed.
 */
systemCallMethods.unroot = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(this.executable.path, ['unroot']));

      case 3:
        return context$1$0.abrupt('return', true);

      case 6:
        context$1$0.prev = 6;
        context$1$0.t0 = context$1$0['catch'](0);

        _loggerJs2['default'].warn('Unable to unroot adb daemon: \'' + context$1$0.t0.message + '\'. Continuing');
        return context$1$0.abrupt('return', false);

      case 10:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 6]]);
};

/**
 * Verify whether a remote path exists on the device under test.
 *
 * @param {string} remotePath - The remote path to verify.
 * @return {boolean} True if the given path exists on the device.
 */
systemCallMethods.fileExists = function callee$0$0(remotePath) {
  var files;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.ls(remotePath));

      case 2:
        files = context$1$0.sent;
        return context$1$0.abrupt('return', files.length > 0);

      case 4:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Get the output of _ls_ command on the device under test.
 *
 * @param {string} remotePath - The remote path (the first argument to the _ls_ command).
 * @param {Array.<String>} opts [[]] - Additional _ls_ options.
 * @return {Array.<String>} The _ls_ output as an array of split lines.
 *                          An empty array is returned of the given _remotePath_
 *                          does not exist.
 */
systemCallMethods.ls = function callee$0$0(remotePath) {
  var opts = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
  var args, stdout, lines;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        args = ['ls'].concat(_toConsumableArray(opts), [remotePath]);
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.shell(args));

      case 4:
        stdout = context$1$0.sent;
        lines = stdout.split("\n");
        return context$1$0.abrupt('return', lines.map(function (l) {
          return l.trim();
        }).filter(Boolean).filter(function (l) {
          return l.indexOf("No such file") === -1;
        }));

      case 9:
        context$1$0.prev = 9;
        context$1$0.t0 = context$1$0['catch'](0);

        if (!(context$1$0.t0.message.indexOf('No such file or directory') === -1)) {
          context$1$0.next = 13;
          break;
        }

        throw context$1$0.t0;

      case 13:
        return context$1$0.abrupt('return', []);

      case 14:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 9]]);
};

/**
 * Get the size of the particular file located on the device under test.
 *
 * @param {string} remotePath - The remote path to the file.
 * @return {number} File size in bytes.
 * @throws {Error} If there was an error while getting the size of the given file.
 */
systemCallMethods.fileSize = function callee$0$0(remotePath) {
  var files, match;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.ls(remotePath, ['-la']));

      case 3:
        files = context$1$0.sent;

        if (!(files.length !== 1)) {
          context$1$0.next = 6;
          break;
        }

        throw new Error('Remote path is not a file');

      case 6:
        match = /[rwxsStT\-\+]{10}[\s\d]*\s[^\s]+\s+[^\s]+\s+(\d+)/.exec(files[0]);

        if (!(!match || _lodash2['default'].isNaN(parseInt(match[1], 10)))) {
          context$1$0.next = 9;
          break;
        }

        throw new Error('Unable to parse size from list output: \'' + files[0] + '\'');

      case 9:
        return context$1$0.abrupt('return', parseInt(match[1], 10));

      case 12:
        context$1$0.prev = 12;
        context$1$0.t0 = context$1$0['catch'](0);
        throw new Error('Unable to get file size for \'' + remotePath + '\': ' + context$1$0.t0.message);

      case 15:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 12]]);
};

/**
 * Installs the given certificate on a rooted real device or
 * an emulator. The emulator must be executed with `-writable-system`
 * command line option and adb daemon should be running in root
 * mode for this method to work properly. The method also requires
 * openssl tool to be available on the destination system.
 * Read https://github.com/appium/appium/issues/10964
 * for more details on this topic
 *
 * @param {Buffer|string} cert - base64-decoded content of the actual certificate
 * represented as a string or a buffer
 * @throws {Error} If openssl tool is not available on the destination system
 * or if there was an error while installing the certificate
 */
systemCallMethods.installMitmCertificate = function callee$0$0(cert) {
  var openSsl, tmpRoot, srcCert, _ref5, stdout, certHash, _ref6, dstCertContent, _ref7, dstCert;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this8 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap((0, _helpers.getOpenSslForOs)());

      case 2:
        openSsl = context$1$0.sent;

        if (!_lodash2['default'].isBuffer(cert)) {
          cert = Buffer.from(cert, 'base64');
        }

        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(_appiumSupport.tempDir.openDir());

      case 6:
        tmpRoot = context$1$0.sent;
        context$1$0.prev = 7;
        srcCert = _path2['default'].resolve(tmpRoot, 'source.cer');
        context$1$0.next = 11;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.writeFile(srcCert, cert));

      case 11:
        context$1$0.next = 13;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(openSsl, ['x509', '-noout', '-hash', '-in', srcCert]));

      case 13:
        _ref5 = context$1$0.sent;
        stdout = _ref5.stdout;
        certHash = stdout.trim();

        _loggerJs2['default'].debug('Got certificate hash: ' + certHash);
        _loggerJs2['default'].debug('Preparing certificate content');
        context$1$0.next = 20;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(openSsl, ['x509', '-in', srcCert], { isBuffer: true }));

      case 20:
        _ref6 = context$1$0.sent;
        stdout = _ref6.stdout;
        dstCertContent = stdout;
        context$1$0.next = 25;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(openSsl, ['x509', '-in', srcCert, '-text', '-fingerprint', '-noout'], { isBuffer: true }));

      case 25:
        _ref7 = context$1$0.sent;
        stdout = _ref7.stdout;

        dstCertContent = Buffer.concat([dstCertContent, stdout]);
        dstCert = _path2['default'].resolve(tmpRoot, certHash + '.0');
        context$1$0.next = 31;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.writeFile(dstCert, dstCertContent));

      case 31:
        _loggerJs2['default'].debug('Mounting /system endpoint');
        // Sometimes emulator reboot is still not fully finished on this stage, so retry
        context$1$0.next = 34;
        return _regeneratorRuntime.awrap((0, _asyncbox.retryInterval)(5, 2000, function callee$1$0() {
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.next = 2;
                return _regeneratorRuntime.awrap(this.shell(['mount', '-o', 'rw,remount', '/system']));

              case 2:
                return context$2$0.abrupt('return', context$2$0.sent);

              case 3:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this8);
        }));

      case 34:
        _loggerJs2['default'].debug('Uploading the generated certificate from \'' + dstCert + '\' to \'' + CERTS_ROOT + '\'');
        context$1$0.next = 37;
        return _regeneratorRuntime.awrap(this.push(dstCert, CERTS_ROOT));

      case 37:
        _loggerJs2['default'].debug('Remounting the remote file system');
        context$1$0.next = 40;
        return _regeneratorRuntime.awrap(this.adbExec(['remount']));

      case 40:
        context$1$0.next = 45;
        break;

      case 42:
        context$1$0.prev = 42;
        context$1$0.t0 = context$1$0['catch'](7);
        throw new Error('Cannot inject the custom certificate. ' + 'Is the certificate properly encoded into base64-string? ' + 'Do you have root permissions on the device? ' + ('Original error: ' + context$1$0.t0.message));

      case 45:
        context$1$0.prev = 45;
        context$1$0.next = 48;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.rimraf(tmpRoot));

      case 48:
        return context$1$0.finish(45);

      case 49:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[7, 42, 45, 49]]);
};

/**
 * Verifies if the given root certificate is already installed on the device.
 *
 * @param {Buffer|string} cert - base64-decoded content of the actual certificate
 * represented as a string or a buffer
 * @throws {Error} If openssl tool is not available on the destination system
 * or if there was an error while checking the certificate
 * @returns {boolean} true if the given certificate is already installed
 */
systemCallMethods.isMitmCertificateInstalled = function callee$0$0(cert) {
  var openSsl, tmpRoot, certHash, tmpCert, _ref8, stdout, dstPath;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap((0, _helpers.getOpenSslForOs)());

      case 2:
        openSsl = context$1$0.sent;

        if (!_lodash2['default'].isBuffer(cert)) {
          cert = Buffer.from(cert, 'base64');
        }

        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(_appiumSupport.tempDir.openDir());

      case 6:
        tmpRoot = context$1$0.sent;
        certHash = undefined;
        context$1$0.prev = 8;
        tmpCert = _path2['default'].resolve(tmpRoot, 'source.cer');
        context$1$0.next = 12;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.writeFile(tmpCert, cert));

      case 12:
        context$1$0.next = 14;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(openSsl, ['x509', '-noout', '-hash', '-in', tmpCert]));

      case 14:
        _ref8 = context$1$0.sent;
        stdout = _ref8.stdout;

        certHash = stdout.trim();
        context$1$0.next = 22;
        break;

      case 19:
        context$1$0.prev = 19;
        context$1$0.t0 = context$1$0['catch'](8);
        throw new Error('Cannot retrieve the certificate hash. ' + 'Is the certificate properly encoded into base64-string? ' + ('Original error: ' + context$1$0.t0.message));

      case 22:
        context$1$0.prev = 22;
        context$1$0.next = 25;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.rimraf(tmpRoot));

      case 25:
        return context$1$0.finish(22);

      case 26:
        dstPath = _path2['default'].posix.resolve(CERTS_ROOT, certHash + '.0');

        _loggerJs2['default'].debug('Checking if the certificate is already installed at \'' + dstPath + '\'');
        context$1$0.next = 30;
        return _regeneratorRuntime.awrap(this.fileExists(dstPath));

      case 30:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 31:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[8, 19, 22, 26]]);
};

exports['default'] = systemCallMethods;
module.exports = exports['default'];

// get subpaths for currently installed build tool directories

// expecting adb devices to return output as
// List of devices attached
// emulator-5554	device

// cool down

// cool down

// The methods is used to remove telnet auth token
//

// Sometimes the package manager service might still being initialized
// on slow systems even after emulator booting is completed.
// The usual output of `pm get-install-location` command looks like `0[auto]`
// let the emu finish stopping;

// we don't want the stack trace, so no log.errorAndThrow

// on real devices in some situations we get an error in the stdout

// https://regex101.com/r/fOs4P4/8
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi90b29scy9zeXN0ZW0tY2FsbHMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7b0JBQWlCLE1BQU07Ozs7d0JBQ1AsY0FBYzs7Ozt3QkFDaEIsVUFBVTs7Ozs2QkFDa0IsZ0JBQWdCOzt1QkFFakMsWUFBWTs7NEJBQ0osY0FBYzs7d0JBQ2UsVUFBVTs7c0JBQzFELFFBQVE7Ozs7MEJBQ0EsYUFBYTs7QUFHbkMsSUFBSSxpQkFBaUIsR0FBRyxFQUFFLENBQUM7O0FBRTNCLElBQU0sd0JBQXdCLEdBQUcsS0FBSyxDQUFDO0FBQ3ZDLElBQU0sMEJBQTBCLEdBQUcsRUFBRSxDQUFDOztBQUV0QyxJQUFNLHFCQUFxQixHQUFHLHNCQUFzQixDQUFDO0FBQ3JELElBQU0sMkJBQTJCLEdBQUcsSUFBSSxNQUFNLENBQUMsZ0NBQWdDLEVBQUUsR0FBRyxDQUFDLENBQUM7QUFDdEYsSUFBTSw2QkFBNkIsR0FBRyxJQUFJLE1BQU0sc0NBQW9DLEdBQUcsQ0FBQyxDQUFDO0FBQ3pGLElBQU0sOEJBQThCLEdBQUcsSUFBSSxNQUFNLENBQUMsZ0NBQWdDLEVBQUUsR0FBRyxDQUFDLENBQUM7O0FBRXpGLElBQU0sVUFBVSxHQUFHLDhCQUE4QixDQUFDOzs7Ozs7OztBQVFsRCxpQkFBaUIsQ0FBQyxnQkFBZ0IsR0FBRyxvQkFBRSxPQUFPLENBQUMsb0JBQWdCLFVBQVU7Ozs7QUFDdkUsOEJBQUksSUFBSSx1QkFBcUIsVUFBVSxpQkFBYyxDQUFDOzthQUNsRCxJQUFJLENBQUMsT0FBTzs7Ozs7O3lDQUNELElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxVQUFVLENBQUM7Ozs7OztBQUVwRCw4QkFBSSxJQUFJLENBQUMsMklBQ2tFLCtDQUN6QixVQUFVLE9BQUcsQ0FBQyxDQUFDOzt5Q0FDcEQsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFVBQVUsQ0FBQzs7Ozs7Ozs7OztDQUNoRCxDQUFDLENBQUM7Ozs7Ozs7OztBQVNILGlCQUFpQixDQUFDLGVBQWUsR0FB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SSxDQUFDOzt5Q0FDakUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUM7Ozs7Ozs7Ozs7Q0FDdEMsQ0FBQzs7cUJBRWEsaUJBQWlCIiwiZmlsZSI6ImxpYi90b29scy9zeXN0ZW0tY2FsbHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCBsb2cgZnJvbSAnLi4vbG9nZ2VyLmpzJztcbmltcG9ydCBCIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCB7IHN5c3RlbSwgZnMsIHV0aWwsIHRlbXBEaXIgfSBmcm9tICdhcHBpdW0tc3VwcG9ydCc7XG5pbXBvcnQgeyBnZXRTZGtUb29sc1ZlcnNpb24sIGdldEJ1aWxkVG9vbHNEaXJzLFxuICBnZXRPcGVuU3NsRm9yT3MgfSBmcm9tICcuLi9oZWxwZXJzJztcbmltcG9ydCB7IGV4ZWMsIFN1YlByb2Nlc3MgfSBmcm9tICd0ZWVuX3Byb2Nlc3MnO1xuaW1wb3J0IHsgc2xlZXAsIHJldHJ5LCByZXRyeUludGVydmFsLCB3YWl0Rm9yQ29uZGl0aW9uIH0gZnJvbSAnYXN5bmNib3gnO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IHF1b3RlIH0gZnJvbSAnc2hlbGwtcXVvdGUnO1xuXG5cbmxldCBzeXN0ZW1DYWxsTWV0aG9kcyA9IHt9O1xuXG5jb25zdCBERUZBVUxUX0FEQl9FWEVDX1RJTUVPVVQgPSAyMDAwMDsgLy8gaW4gbWlsbGlzZWNvbmRzXG5jb25zdCBERUZBVUxUX0FEQl9SRUJPT1RfUkVUUklFUyA9IDkwO1xuXG5jb25zdCBMSU5LRVJfV0FSTklOR19SRUdFWFAgPSAvXldBUk5JTkc6IGxpbmtlci4rJC9tO1xuY29uc3QgUFJPVE9DT0xfRkFVTFRfRVJST1JfUkVHRVhQID0gbmV3IFJlZ0V4cCgncHJvdG9jb2wgZmF1bHQgXFxcXChubyBzdGF0dXNcXFxcKScsICdpJyk7XG5jb25zdCBERVZJQ0VfTk9UX0ZPVU5EX0VSUk9SX1JFR0VYUCA9IG5ldyBSZWdFeHAoYGVycm9yOiBkZXZpY2UgKCcuKycgKT9ub3QgZm91bmRgLCAnaScpO1xuY29uc3QgREVWSUNFX0NPTk5FQ1RJTkdfRVJST1JfUkVHRVhQID0gbmV3IFJlZ0V4cCgnZXJyb3I6IGRldmljZSBzdGlsbCBjb25uZWN0aW5nJywgJ2knKTtcblxuY29uc3QgQ0VSVFNfUk9PVCA9ICcvc3lzdGVtL2V0Yy9zZWN1cml0eS9jYWNlcnRzJztcblxuLyoqXG4gKiBSZXRyaWV2ZSBmdWxsIHBhdGggdG8gdGhlIGdpdmVuIGJpbmFyeS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmluYXJ5TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBiaW5hcnkuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEZ1bGwgcGF0aCB0byB0aGUgZ2l2ZW4gYmluYXJ5IGluY2x1ZGluZyBjdXJyZW50IFNESyByb290LlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRTZGtCaW5hcnlQYXRoID0gXy5tZW1vaXplKGFzeW5jIGZ1bmN0aW9uIChiaW5hcnlOYW1lKSB7XG4gIGxvZy5pbmZvKGBDaGVja2luZyB3aGV0aGVyICR7YmluYXJ5TmFtZX0gaXMgcHJlc2VudGApO1xuICBpZiAodGhpcy5zZGtSb290KSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0QmluYXJ5RnJvbVNka1Jvb3QoYmluYXJ5TmFtZSk7XG4gIH1cbiAgbG9nLndhcm4oYFRoZSBBTkRST0lEX0hPTUUgZW52aXJvbm1lbnQgdmFyaWFibGUgaXMgbm90IHNldCB0byB0aGUgQW5kcm9pZCBTREsgYCArXG4gICAgICAgICAgIGByb290IGRpcmVjdG9yeSBwYXRoLiBBTkRST0lEX0hPTUUgaXMgcmVxdWlyZWQgZm9yIGNvbXBhdGliaWxpdHkgYCArXG4gICAgICAgICAgIGB3aXRoIFNESyAyMysuIENoZWNraW5nIGFsb25nIFBBVEggZm9yICR7YmluYXJ5TmFtZX0uYCk7XG4gIHJldHVybiBhd2FpdCB0aGlzLmdldEJpbmFyeUZyb21QYXRoKGJpbmFyeU5hbWUpO1xufSk7XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIG5hbWUgb2YgdGhlIHRvb2wsXG4gKiB3aGljaCBwcmludHMgZnVsbCBwYXRoIHRvIHRoZSBnaXZlbiBjb21tYW5kIHNob3J0Y3V0LlxuICpcbiAqIEByZXR1cm4ge3N0cmluZ30gRGVwZW5kaW5nIG9uIHRoZSBjdXJyZW50IHBsYXRmb3JtIHRoaXMgaXNcbiAqICAgICAgICAgICAgICAgICAgc3VwcG9zZWQgdG8gYmUgZWl0aGVyICd3aGljaCcgb3IgJ3doZXJlJy5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0Q29tbWFuZEZvck9TID0gXy5tZW1vaXplKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHN5c3RlbS5pc1dpbmRvd3MoKSA/ICd3aGVyZScgOiAnd2hpY2gnO1xufSk7XG5cbi8qKlxuICogUmV0cmlldmUgZnVsbCBiaW5hcnkgbmFtZSBmb3IgdGhlIGN1cnJlbnQgb3BlcmF0aW5nIHN5c3RlbS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmluYXJ5TmFtZSAtIHNpbXBsZSBiaW5hcnkgbmFtZSwgZm9yIGV4YW1wbGUgJ2FuZHJvaWQnLlxuICogQHJldHVybiB7c3RyaW5nfSBGb3JtYXR0ZWQgYmluYXJ5IG5hbWUgZGVwZW5kaW5nIG9uIHRoZSBjdXJyZW50IHBsYXRmb3JtLFxuICogICAgICAgICAgICAgICAgICBmb3IgZXhhbXBsZSwgJ2FuZHJvaWQuYmF0JyBvbiBXaW5kb3dzLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRCaW5hcnlOYW1lRm9yT1MgPSBfLm1lbW9pemUoZnVuY3Rpb24gKGJpbmFyeU5hbWUpIHtcbiAgaWYgKCFzeXN0ZW0uaXNXaW5kb3dzKCkpIHtcbiAgICByZXR1cm4gYmluYXJ5TmFtZTtcbiAgfVxuXG4gIGlmIChbJ2FuZHJvaWQnLCAnYXBrc2lnbmVyJywgJ2Fwa2FuYWx5emVyJ10uaW5kZXhPZihiaW5hcnlOYW1lKSA+PSAwICYmXG4gICAgICAhYmluYXJ5TmFtZS50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKCcuYmF0JykpIHtcbiAgICByZXR1cm4gYCR7YmluYXJ5TmFtZX0uYmF0YDtcbiAgfVxuICBpZiAoIWJpbmFyeU5hbWUudG9Mb3dlckNhc2UoKS5lbmRzV2l0aCgnLmV4ZScpKSB7XG4gICAgcmV0dXJuIGAke2JpbmFyeU5hbWV9LmV4ZWA7XG4gIH1cbiAgcmV0dXJuIGJpbmFyeU5hbWU7XG59KTtcblxuLyoqXG4gKiBSZXRyaWV2ZSBmdWxsIHBhdGggdG8gdGhlIGdpdmVuIGJpbmFyeS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmluYXJ5TmFtZSAtIFNpbXBsZSBuYW1lIG9mIGEgYmluYXJ5IGZpbGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEZ1bGwgcGF0aCB0byB0aGUgZ2l2ZW4gYmluYXJ5LiBUaGUgbWV0aG9kIHRyaWVzXG4gKiAgICAgICAgICAgICAgICAgIHRvIGVudW1lcmF0ZSBhbGwgdGhlIGtub3duIGxvY2F0aW9ucyB3aGVyZSB0aGUgYmluYXJ5XG4gKiAgICAgICAgICAgICAgICAgIG1pZ2h0IGJlIGxvY2F0ZWQgYW5kIHN0b3BzIHRoZSBzZWFyY2ggYXMgc29vbiBhcyB0aGUgZmlyc3RcbiAqICAgICAgICAgICAgICAgICAgbWF0Y2ggaXMgZm91bmQgb24gdGhlIGxvY2FsIGZpbGUgc3lzdGVtLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBiaW5hcnkgd2l0aCBnaXZlbiBuYW1lIGlzIG5vdCBwcmVzZW50IGF0IGFueVxuICogICAgICAgICAgICAgICAgIG9mIGtub3duIGxvY2F0aW9ucyBvciBBbmRyb2lkIFNESyBpcyBub3QgaW5zdGFsbGVkIG9uIHRoZVxuICogICAgICAgICAgICAgICAgIGxvY2FsIGZpbGUgc3lzdGVtLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRCaW5hcnlGcm9tU2RrUm9vdCA9IF8ubWVtb2l6ZShhc3luYyBmdW5jdGlvbiAoYmluYXJ5TmFtZSkge1xuICBsZXQgYmluYXJ5TG9jID0gbnVsbDtcbiAgYmluYXJ5TmFtZSA9IHRoaXMuZ2V0QmluYXJ5TmFtZUZvck9TKGJpbmFyeU5hbWUpO1xuICBsZXQgYmluYXJ5TG9jcyA9IFtcbiAgICBwYXRoLnJlc29sdmUodGhpcy5zZGtSb290LCBcInBsYXRmb3JtLXRvb2xzXCIsIGJpbmFyeU5hbWUpLFxuICAgIHBhdGgucmVzb2x2ZSh0aGlzLnNka1Jvb3QsIFwiZW11bGF0b3JcIiwgYmluYXJ5TmFtZSksXG4gICAgcGF0aC5yZXNvbHZlKHRoaXMuc2RrUm9vdCwgXCJ0b29sc1wiLCBiaW5hcnlOYW1lKSxcbiAgICBwYXRoLnJlc29sdmUodGhpcy5zZGtSb290LCBcInRvb2xzXCIsIFwiYmluXCIsIGJpbmFyeU5hbWUpXG4gIF07XG4gIC8vIGdldCBzdWJwYXRocyBmb3IgY3VycmVudGx5IGluc3RhbGxlZCBidWlsZCB0b29sIGRpcmVjdG9yaWVzXG4gIF8uZm9yRWFjaChhd2FpdCBnZXRCdWlsZFRvb2xzRGlycyh0aGlzLnNka1Jvb3QpLFxuICAgICAgICAgICAgKGRpcikgPT4gYmluYXJ5TG9jcy5wdXNoKHBhdGgucmVzb2x2ZShkaXIsIGJpbmFyeU5hbWUpKSk7XG4gIGZvciAobGV0IGxvYyBvZiBiaW5hcnlMb2NzKSB7XG4gICAgaWYgKGF3YWl0IGZzLmV4aXN0cyhsb2MpKSB7XG4gICAgICBiaW5hcnlMb2MgPSBsb2M7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKF8uaXNOdWxsKGJpbmFyeUxvYykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kICR7YmluYXJ5TmFtZX0gaW4gJHtiaW5hcnlMb2NzfS4gYCArXG4gICAgICAgICAgICAgICAgICAgIGBEbyB5b3UgaGF2ZSB0aGUgQW5kcm9pZCBTREsgaW5zdGFsbGVkIGF0ICcke3RoaXMuc2RrUm9vdH0nP2ApO1xuICB9XG4gIGJpbmFyeUxvYyA9IGJpbmFyeUxvYy50cmltKCk7XG4gIGxvZy5pbmZvKGBVc2luZyAke2JpbmFyeU5hbWV9IGZyb20gJHtiaW5hcnlMb2N9YCk7XG4gIHJldHVybiBiaW5hcnlMb2M7XG59KTtcblxuLyoqXG4gKiBSZXRyaWV2ZSBmdWxsIHBhdGggdG8gYSBiaW5hcnkgZmlsZSB1c2luZyB0aGUgc3RhbmRhcmQgc3lzdGVtIGxvb2t1cCB0b29sLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiaW5hcnlOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGJpbmFyeS5cbiAqIEByZXR1cm4ge3N0cmluZ30gRnVsbCBwYXRoIHRvIHRoZSBiaW5hcnkgcmVjZWl2ZWQgZnJvbSAnd2hpY2gnLyd3aGVyZSdcbiAqICAgICAgICAgICAgICAgICAgb3V0cHV0LlxuICogQHRocm93cyB7RXJyb3J9IElmIGxvb2t1cCB0b29sIHJldHVybnMgbm9uLXplcm8gcmV0dXJuIGNvZGUuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldEJpbmFyeUZyb21QYXRoID0gYXN5bmMgZnVuY3Rpb24gKGJpbmFyeU5hbWUpIHtcbiAgbGV0IGJpbmFyeUxvYyA9IG51bGw7XG4gIGxldCBjbWQgPSB0aGlzLmdldENvbW1hbmRGb3JPUygpO1xuICB0cnkge1xuICAgIGxldCB7c3Rkb3V0fSA9IGF3YWl0IGV4ZWMoY21kLCBbYmluYXJ5TmFtZV0pO1xuICAgIGxvZy5pbmZvKGBVc2luZyAke2JpbmFyeU5hbWV9IGZyb20gJHtzdGRvdXR9YCk7XG4gICAgLy8gVE9ETyB3cml0ZSBhIHRlc3QgZm9yIGJpbmFyaWVzIHdpdGggc3BhY2VzLlxuICAgIGJpbmFyeUxvYyA9IHN0ZG91dC50cmltKCk7XG4gICAgcmV0dXJuIGJpbmFyeUxvYztcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgJHtiaW5hcnlOYW1lfSBQbGVhc2Ugc2V0IHRoZSBBTkRST0lEX0hPTUUgYCArXG4gICAgICAgICAgICAgIGBlbnZpcm9ubWVudCB2YXJpYWJsZSB3aXRoIHRoZSBBbmRyb2lkIFNESyByb290IGRpcmVjdG9yeSBwYXRoLmApO1xuICB9XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERldmljZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHVkaWQgLSBUaGUgZGV2aWNlIHVkaWQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc3RhdGUgLSBDdXJyZW50IGRldmljZSBzdGF0ZSwgYXMgaXQgaXMgdmlzaWJsZSBpblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgX2FkYiBkZXZpY2VzIC1sXyBvdXRwdXQuXG4gKi9cblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgbGlzdCBvZiBkZXZpY2VzIHZpc2libGUgdG8gYWRiLlxuICpcbiAqIEByZXR1cm4ge0FycmF5LjxEZXZpY2U+fSBUaGUgbGlzdCBvZiBkZXZpY2VzIG9yIGFuIGVtcHR5IGxpc3QgaWZcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBubyBkZXZpY2VzIGFyZSBjb25uZWN0ZWQuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGxpc3RpbmcgZGV2aWNlcy5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0Q29ubmVjdGVkRGV2aWNlcyA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgbG9nLmRlYnVnKFwiR2V0dGluZyBjb25uZWN0ZWQgZGV2aWNlcy4uLlwiKTtcbiAgdHJ5IHtcbiAgICBsZXQge3N0ZG91dH0gPSBhd2FpdCBleGVjKHRoaXMuZXhlY3V0YWJsZS5wYXRoLCB0aGlzLmV4ZWN1dGFibGUuZGVmYXVsdEFyZ3MuY29uY2F0KFsnZGV2aWNlcyddKSk7XG4gICAgLy8gZXhwZWN0aW5nIGFkYiBkZXZpY2VzIHRvIHJldHVybiBvdXRwdXQgYXNcbiAgICAvLyBMaXN0IG9mIGRldmljZXMgYXR0YWNoZWRcbiAgICAvLyBlbXVsYXRvci01NTU0XHRkZXZpY2VcbiAgICBsZXQgc3RhcnRpbmdJbmRleCA9IHN0ZG91dC5pbmRleE9mKFwiTGlzdCBvZiBkZXZpY2VzXCIpO1xuICAgIGlmIChzdGFydGluZ0luZGV4ID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIG91dHB1dCB3aGlsZSB0cnlpbmcgdG8gZ2V0IGRldmljZXMuIG91dHB1dCB3YXM6ICR7c3Rkb3V0fWApO1xuICAgIH1cbiAgICAvLyBzbGljaW5nIG91cHV0IHdlIGNhcmUgYWJvdXQuXG4gICAgc3Rkb3V0ID0gc3Rkb3V0LnNsaWNlKHN0YXJ0aW5nSW5kZXgpO1xuICAgIGxldCBkZXZpY2VzID0gW107XG4gICAgZm9yIChsZXQgbGluZSBvZiBzdGRvdXQuc3BsaXQoXCJcXG5cIikpIHtcbiAgICAgIGlmIChsaW5lLnRyaW0oKSAhPT0gXCJcIiAmJlxuICAgICAgICAgIGxpbmUuaW5kZXhPZihcIkxpc3Qgb2YgZGV2aWNlc1wiKSA9PT0gLTEgJiZcbiAgICAgICAgICBsaW5lLmluZGV4T2YoXCJhZGIgc2VydmVyXCIpID09PSAtMSAmJlxuICAgICAgICAgIGxpbmUuaW5kZXhPZihcIiogZGFlbW9uXCIpID09PSAtMSAmJlxuICAgICAgICAgIGxpbmUuaW5kZXhPZihcIm9mZmxpbmVcIikgPT09IC0xKSB7XG4gICAgICAgIGxldCBsaW5lSW5mbyA9IGxpbmUuc3BsaXQoXCJcXHRcIik7XG4gICAgICAgIC8vIHN0YXRlIGlzIGVpdGhlciBcImRldmljZVwiIG9yIFwib2ZmbGluZVwiLCBhZmFpY3RcbiAgICAgICAgZGV2aWNlcy5wdXNoKHt1ZGlkOiBsaW5lSW5mb1swXSwgc3RhdGU6IGxpbmVJbmZvWzFdfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxvZy5kZWJ1ZyhgJHtkZXZpY2VzLmxlbmd0aH0gZGV2aWNlKHMpIGNvbm5lY3RlZGApO1xuICAgIHJldHVybiBkZXZpY2VzO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciB3aGlsZSBnZXR0aW5nIGNvbm5lY3RlZCBkZXZpY2VzLiBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIGxpc3Qgb2YgZGV2aWNlcyB2aXNpYmxlIHRvIGFkYiB3aXRoaW4gdGhlIGdpdmVuIHRpbWVvdXQuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRNcyAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZ2V0IGF0IGxlYXN0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25lIGxpc3QgaXRlbS5cbiAqIEByZXR1cm4ge0FycmF5LjxEZXZpY2U+fSBUaGUgbGlzdCBvZiBjb25uZWN0ZWQgZGV2aWNlcy5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBubyBjb25uZWN0ZWQgZGV2aWNlcyBjYW4gYmUgZGV0ZWN0ZWQgd2l0aGluIHRoZSBnaXZlbiB0aW1lb3V0LlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXREZXZpY2VzV2l0aFJldHJ5ID0gYXN5bmMgZnVuY3Rpb24gKHRpbWVvdXRNcyA9IDIwMDAwKSB7XG4gIGxldCBzdGFydCA9IERhdGUubm93KCk7XG4gIGxvZy5kZWJ1ZyhcIlRyeWluZyB0byBmaW5kIGEgY29ubmVjdGVkIGFuZHJvaWQgZGV2aWNlXCIpO1xuICBsZXQgZ2V0RGV2aWNlcyA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoKERhdGUubm93KCkgLSBzdGFydCkgPiB0aW1lb3V0TXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIGEgY29ubmVjdGVkIEFuZHJvaWQgZGV2aWNlLlwiKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGxldCBkZXZpY2VzID0gYXdhaXQgdGhpcy5nZXRDb25uZWN0ZWREZXZpY2VzKCk7XG4gICAgICBpZiAoZGV2aWNlcy5sZW5ndGggPCAxKSB7XG4gICAgICAgIGxvZy5kZWJ1ZyhcIkNvdWxkIG5vdCBmaW5kIGRldmljZXMsIHJlc3RhcnRpbmcgYWRiIHNlcnZlci4uLlwiKTtcbiAgICAgICAgYXdhaXQgdGhpcy5yZXN0YXJ0QWRiKCk7XG4gICAgICAgIC8vIGNvb2wgZG93blxuICAgICAgICBhd2FpdCBzbGVlcCgyMDApO1xuICAgICAgICByZXR1cm4gYXdhaXQgZ2V0RGV2aWNlcygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRldmljZXM7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nLmRlYnVnKFwiQ291bGQgbm90IGZpbmQgZGV2aWNlcywgcmVzdGFydGluZyBhZGIgc2VydmVyLi4uXCIpO1xuICAgICAgYXdhaXQgdGhpcy5yZXN0YXJ0QWRiKCk7XG4gICAgICAvLyBjb29sIGRvd25cbiAgICAgIGF3YWl0IHNsZWVwKDIwMCk7XG4gICAgICByZXR1cm4gYXdhaXQgZ2V0RGV2aWNlcygpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGF3YWl0IGdldERldmljZXMoKTtcbn07XG5cbi8qKlxuICogUmVzdGFydCBhZGIgc2VydmVyIGlmIF90aGlzLnN1cHByZXNzS2lsbFNlcnZlcl8gcHJvcGVydHkgaXMgdHJ1ZS5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMucmVzdGFydEFkYiA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuc3VwcHJlc3NLaWxsU2VydmVyKSB7XG4gICAgbG9nLmRlYnVnKGBOb3QgcmVzdGFydGluZyBhYmQgc2luY2UgJ3N1cHByZXNzS2lsbFNlcnZlcicgaXMgb25gKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBsb2cuZGVidWcoJ1Jlc3RhcnRpbmcgYWRiJyk7XG4gIHRyeSB7XG4gICAgYXdhaXQgdGhpcy5raWxsU2VydmVyKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsb2cuZXJyb3IoXCJFcnJvciBraWxsaW5nIEFEQiBzZXJ2ZXIsIGdvaW5nIHRvIHNlZSBpZiBpdCdzIG9ubGluZSBhbnl3YXlcIik7XG4gIH1cbn07XG5cbi8qKlxuICogS2lsbCBhZGIgc2VydmVyLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5raWxsU2VydmVyID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICBsb2cuZGVidWcoYEtpbGxpbmcgYWRiIHNlcnZlciBvbiBwb3J0ICR7dGhpcy5hZGJQb3J0fWApO1xuICBhd2FpdCBleGVjKHRoaXMuZXhlY3V0YWJsZS5wYXRoLCBbLi4udGhpcy5leGVjdXRhYmxlLmRlZmF1bHRBcmdzLCAna2lsbC1zZXJ2ZXInXSk7XG59O1xuXG4vKipcbiAqIFJlc2V0IFRlbG5ldCBhdXRoZW50aWNhdGlvbiB0b2tlbi5cbiAqIEBzZWUge0BsaW5rIGh0dHA6Ly90b29scy5hbmRyb2lkLmNvbS9yZWNlbnQvZW11bGF0b3IyNTE2cmVsZWFzZW5vdGVzfSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBJZiB0b2tlbiByZXNldCB3YXMgc3VjY2Vzc2Z1bC5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMucmVzZXRUZWxuZXRBdXRoVG9rZW4gPSBfLm1lbW9pemUoYXN5bmMgZnVuY3Rpb24gKCkge1xuICAvLyBUaGUgbWV0aG9kcyBpcyB1c2VkIHRvIHJlbW92ZSB0ZWxuZXQgYXV0aCB0b2tlblxuICAvL1xuICBjb25zdCBob21lRm9sZGVyUGF0aCA9IHByb2Nlc3MuZW52Wyhwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSA/ICdVU0VSUFJPRklMRScgOiAnSE9NRSddO1xuICBpZiAoIWhvbWVGb2xkZXJQYXRoKSB7XG4gICAgbG9nLndhcm4oJ0Nhbm5vdCBmaW5kIHRoZSBwYXRoIHRvIHVzZXIgaG9tZSBmb2xkZXIuIElnbm9yaW5nIHJlc2V0dGluZyBvZiBlbXVsYXRvclxcJ3MgdGVsbmV0IGF1dGhlbnRpY2F0aW9uIHRva2VuJyk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGRzdFBhdGggPSBwYXRoLnJlc29sdmUoaG9tZUZvbGRlclBhdGgsICcuZW11bGF0b3JfY29uc29sZV9hdXRoX3Rva2VuJyk7XG4gIGxvZy5kZWJ1ZyhgT3ZlcnJpZGluZyAke2RzdFBhdGh9IHdpdGggYW4gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHRlbG5ldCBhdXRoZW50aWNhdGlvbiBmb3IgZW11bGF0b3IgY29tbWFuZHNgKTtcbiAgdHJ5IHtcbiAgICBhd2FpdCBmcy53cml0ZUZpbGUoZHN0UGF0aCwgJycpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nLndhcm4oYEVycm9yICR7ZS5tZXNzYWdlfSB3aGlsZSByZXNldHRpbmcgdGhlIGNvbnRlbnQgb2YgJHtkc3RQYXRofS4gSWdub3JpbmcgcmVzZXR0aW5nIG9mIGVtdWxhdG9yXFwncyB0ZWxuZXQgYXV0aGVudGljYXRpb24gdG9rZW5gKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59KTtcblxuLyoqXG4gKiBFeGVjdXRlIHRoZSBnaXZlbiBlbXVsYXRvciBjb21tYW5kIHVzaW5nIF9hZGIgZW11XyB0b29sLlxuICpcbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGNtZCAtIFRoZSBhcnJheSBvZiByZXN0IGNvbW1hbmQgbGluZSBwYXJhbWV0ZXJzLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5hZGJFeGVjRW11ID0gYXN5bmMgZnVuY3Rpb24gKGNtZCkge1xuICBhd2FpdCB0aGlzLnZlcmlmeUVtdWxhdG9yQ29ubmVjdGVkKCk7XG4gIGF3YWl0IHRoaXMucmVzZXRUZWxuZXRBdXRoVG9rZW4oKTtcbiAgYXdhaXQgdGhpcy5hZGJFeGVjKFsnZW11JywgLi4uY21kXSk7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGUgdGhlIGdpdmVuIGFkYiBjb21tYW5kLlxuICpcbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGNtZCAtIFRoZSBhcnJheSBvZiByZXN0IGNvbW1hbmQgbGluZSBwYXJhbWV0ZXJzXG4gKiAgICAgICAgICAgICAgICAgICAgICBvciBhIHNpbmdsZSBzdHJpbmcgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBBZGRpdGlvbmFsIG9wdGlvbnMgbWFwcGluZy4gU2VlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vYXBwaXVtL25vZGUtdGVlbl9wcm9jZXNzfVxuICogICAgICAgICAgICAgICAgICAgICAgICBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHJldHVybiB7c3RyaW5nfSAtIENvbW1hbmQncyBzdGRvdXQuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGNvbW1hbmQgcmV0dXJuZWQgbm9uLXplcm8gZXhpdCBjb2RlLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5hZGJFeGVjID0gYXN5bmMgZnVuY3Rpb24gKGNtZCwgb3B0cyA9IHt9KSB7XG4gIGlmICghY21kKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG5lZWQgdG8gcGFzcyBpbiBhIGNvbW1hbmQgdG8gYWRiRXhlYygpXCIpO1xuICB9XG4gIC8vIHNldHRpbmcgZGVmYXVsdCB0aW1lb3V0IGZvciBlYWNoIGNvbW1hbmQgdG8gcHJldmVudCBpbmZpbml0ZSB3YWl0LlxuICBvcHRzLnRpbWVvdXQgPSBvcHRzLnRpbWVvdXQgfHwgdGhpcy5leGVjVGltZW91dCB8fCBERUZBVUxUX0FEQl9FWEVDX1RJTUVPVVQ7XG5cbiAgbGV0IGV4ZWNGdW5jID0gYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIShjbWQgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgY21kID0gW2NtZF07XG4gICAgICB9XG4gICAgICBsZXQgYXJncyA9IHRoaXMuZXhlY3V0YWJsZS5kZWZhdWx0QXJncy5jb25jYXQoY21kKTtcbiAgICAgIGxvZy5kZWJ1ZyhgUnVubmluZyAnJHt0aGlzLmV4ZWN1dGFibGUucGF0aH0gJHtxdW90ZShhcmdzKX0nYCk7XG4gICAgICBsZXQge3N0ZG91dH0gPSBhd2FpdCBleGVjKHRoaXMuZXhlY3V0YWJsZS5wYXRoLCBhcmdzLCBvcHRzKTtcbiAgICAgIC8vIHNvbWV0aW1lcyBBREIgcHJpbnRzIG91dCB3ZWlyZCBzdGRvdXQgd2FybmluZ3MgdGhhdCB3ZSBkb24ndCB3YW50XG4gICAgICAvLyB0byBpbmNsdWRlIGluIGFueSBvZiB0aGUgcmVzcG9uc2UgZGF0YSwgc28gbGV0J3Mgc3RyaXAgaXQgb3V0XG4gICAgICBzdGRvdXQgPSBzdGRvdXQucmVwbGFjZShMSU5LRVJfV0FSTklOR19SRUdFWFAsICcnKS50cmltKCk7XG4gICAgICByZXR1cm4gc3Rkb3V0O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnN0IGVyclRleHQgPSBgJHtlLm1lc3NhZ2V9LCAke2Uuc3Rkb3V0fSwgJHtlLnN0ZGVycn1gO1xuICAgICAgY29uc3QgcHJvdG9jb2xGYXVsdEVycm9yID0gUFJPVE9DT0xfRkFVTFRfRVJST1JfUkVHRVhQLnRlc3QoZXJyVGV4dCk7XG4gICAgICBjb25zdCBkZXZpY2VOb3RGb3VuZEVycm9yID0gREVWSUNFX05PVF9GT1VORF9FUlJPUl9SRUdFWFAudGVzdChlcnJUZXh0KTtcbiAgICAgIGNvbnN0IGRldmljZUNvbm5lY3RpbmdFcnJvciA9IERFVklDRV9DT05ORUNUSU5HX0VSUk9SX1JFR0VYUC50ZXN0KGVyclRleHQpO1xuICAgICAgaWYgKHByb3RvY29sRmF1bHRFcnJvciB8fCBkZXZpY2VOb3RGb3VuZEVycm9yIHx8IGRldmljZUNvbm5lY3RpbmdFcnJvcikge1xuICAgICAgICBsb2cuaW5mbyhgRXJyb3Igc2VuZGluZyBjb21tYW5kLCByZWNvbm5lY3RpbmcgZGV2aWNlIGFuZCByZXRyeWluZzogJHtjbWR9YCk7XG4gICAgICAgIGF3YWl0IHNsZWVwKDEwMDApO1xuICAgICAgICBhd2FpdCB0aGlzLmdldERldmljZXNXaXRoUmV0cnkoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGUuY29kZSA9PT0gMCAmJiBlLnN0ZG91dCkge1xuICAgICAgICBsZXQgc3Rkb3V0ID0gZS5zdGRvdXQ7XG4gICAgICAgIHN0ZG91dCA9IHN0ZG91dC5yZXBsYWNlKExJTktFUl9XQVJOSU5HX1JFR0VYUCwgJycpLnRyaW0oKTtcbiAgICAgICAgcmV0dXJuIHN0ZG91dDtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBleGVjdXRpbmcgYWRiRXhlYy4gT3JpZ2luYWwgZXJyb3I6ICcke2UubWVzc2FnZX0nOyBgICtcbiAgICAgICAgICAgICAgICAgICAgICBgU3RkZXJyOiAnJHsoZS5zdGRlcnIgfHwgJycpLnRyaW0oKX0nOyBDb2RlOiAnJHtlLmNvZGV9J2ApO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gYXdhaXQgcmV0cnkoMiwgZXhlY0Z1bmMpO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlIHRoZSBnaXZlbiBjb21tYW5kIHVzaW5nIF9hZGIgc2hlbGxfIHByZWZpeC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fHN0cmluZ30gY21kIC0gVGhlIGFycmF5IG9mIHJlc3QgY29tbWFuZCBsaW5lIHBhcmFtZXRlcnMgb3IgYSBzaW5nbGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBBZGRpdGlvbmFsIG9wdGlvbnMgbWFwcGluZy4gU2VlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vYXBwaXVtL25vZGUtdGVlbl9wcm9jZXNzfVxuICogICAgICAgICAgICAgICAgICAgICAgICBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHJldHVybiB7c3RyaW5nfSAtIENvbW1hbmQncyBzdGRvdXQuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGNvbW1hbmQgcmV0dXJuZWQgbm9uLXplcm8gZXhpdCBjb2RlLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5zaGVsbCA9IGFzeW5jIGZ1bmN0aW9uIChjbWQsIG9wdHMgPSB7fSkge1xuICByZXR1cm4gYXdhaXQgdGhpcy5hZGJFeGVjKF8uaXNBcnJheShjbWQpID8gWydzaGVsbCcsIC4uLmNtZF0gOiBbJ3NoZWxsJywgY21kXSwgb3B0cyk7XG59O1xuXG5zeXN0ZW1DYWxsTWV0aG9kcy5jcmVhdGVTdWJQcm9jZXNzID0gZnVuY3Rpb24gKGFyZ3MgPSBbXSkge1xuICAvLyBhZGQgdGhlIGRlZmF1bHQgYXJndW1lbnRzXG4gIGFyZ3MgPSB0aGlzLmV4ZWN1dGFibGUuZGVmYXVsdEFyZ3MuY29uY2F0KGFyZ3MpO1xuICBsb2cuZGVidWcoYENyZWF0aW5nIEFEQiBzdWJwcm9jZXNzIHdpdGggYXJnczogJHtKU09OLnN0cmluZ2lmeShhcmdzKX1gKTtcbiAgcmV0dXJuIG5ldyBTdWJQcm9jZXNzKHRoaXMuZ2V0QWRiUGF0aCgpLCBhcmdzKTtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIGN1cnJlbnQgYWRiIHBvcnQuXG4gKiBAdG9kbyBjYW4gcHJvYmFibHkgZGVwcmVjYXRlIHRoaXMgbm93IHRoYXQgdGhlIGxvZ2ljIGlzIGp1c3QgdG8gcmVhZCB0aGlzLmFkYlBvcnRcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGN1cnJlbnQgYWRiIHBvcnQgbnVtYmVyLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRBZGJTZXJ2ZXJQb3J0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5hZGJQb3J0O1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgY3VycmVudCBlbXVsYXRvciBwb3J0IGZyb20gX2FkYiBkZXZpdmVzXyBvdXRwdXQuXG4gKlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgY3VycmVudCBlbXVsYXRvciBwb3J0LlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZXJlIGFyZSBubyBjb25uZWN0ZWQgZGV2aWNlcy5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0RW11bGF0b3JQb3J0ID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICBsb2cuZGVidWcoXCJHZXR0aW5nIHJ1bm5pbmcgZW11bGF0b3IgcG9ydFwiKTtcbiAgaWYgKHRoaXMuZW11bGF0b3JQb3J0ICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuZW11bGF0b3JQb3J0O1xuICB9XG4gIHRyeSB7XG4gICAgbGV0IGRldmljZXMgPSBhd2FpdCB0aGlzLmdldENvbm5lY3RlZERldmljZXMoKTtcbiAgICBsZXQgcG9ydCA9IHRoaXMuZ2V0UG9ydEZyb21FbXVsYXRvclN0cmluZyhkZXZpY2VzWzBdLnVkaWQpO1xuICAgIGlmIChwb3J0KSB7XG4gICAgICByZXR1cm4gcG9ydDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFbXVsYXRvciBwb3J0IG5vdCBmb3VuZGApO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTm8gZGV2aWNlcyBjb25uZWN0ZWQuIE9yaWdpbmFsIGVycm9yOiAke2UubWVzc2FnZX1gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgY3VycmVudCBlbXVsYXRvciBwb3J0IGJ5IHBhcnNpbmcgZW11bGF0b3IgbmFtZSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGVtU3RyIC0gRW11bGF0b3IgbmFtZSBzdHJpbmcuXG4gKiBAcmV0dXJuIHtudW1iZXJ8Ym9vbGVhbn0gRWl0aGVyIHRoZSBjdXJyZW50IGVtdWxhdG9yIHBvcnQgb3JcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBfZmFsc2VfIGlmIHBvcnQgbnVtYmVyIGNhbm5vdCBiZSBwYXJzZWQuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldFBvcnRGcm9tRW11bGF0b3JTdHJpbmcgPSBmdW5jdGlvbiAoZW1TdHIpIHtcbiAgbGV0IHBvcnRQYXR0ZXJuID0gL2VtdWxhdG9yLShcXGQrKS87XG4gIGlmIChwb3J0UGF0dGVybi50ZXN0KGVtU3RyKSkge1xuICAgIHJldHVybiBwYXJzZUludChwb3J0UGF0dGVybi5leGVjKGVtU3RyKVsxXSwgMTApO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIGxpc3Qgb2YgY3VycmVudGx5IGNvbm5lY3RlZCBlbXVsYXRvcnMuXG4gKlxuICogQHJldHVybiB7QXJyYXkuPERldmljZT59IFRoZSBsaXN0IG9mIGNvbm5lY3RlZCBkZXZpY2VzLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRDb25uZWN0ZWRFbXVsYXRvcnMgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgbG9nLmRlYnVnKFwiR2V0dGluZyBjb25uZWN0ZWQgZW11bGF0b3JzXCIpO1xuICAgIGxldCBkZXZpY2VzID0gYXdhaXQgdGhpcy5nZXRDb25uZWN0ZWREZXZpY2VzKCk7XG4gICAgbGV0IGVtdWxhdG9ycyA9IFtdO1xuICAgIGZvciAobGV0IGRldmljZSBvZiBkZXZpY2VzKSB7XG4gICAgICBsZXQgcG9ydCA9IHRoaXMuZ2V0UG9ydEZyb21FbXVsYXRvclN0cmluZyhkZXZpY2UudWRpZCk7XG4gICAgICBpZiAocG9ydCkge1xuICAgICAgICBkZXZpY2UucG9ydCA9IHBvcnQ7XG4gICAgICAgIGVtdWxhdG9ycy5wdXNoKGRldmljZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxvZy5kZWJ1ZyhgJHtlbXVsYXRvcnMubGVuZ3RofSBlbXVsYXRvcihzKSBjb25uZWN0ZWRgKTtcbiAgICByZXR1cm4gZW11bGF0b3JzO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBnZXR0aW5nIGVtdWxhdG9ycy4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIFNldCBfZW11bGF0b3JQb3J0XyBwcm9wZXJ0eSBvZiB0aGUgY3VycmVudCBjbGFzcy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZW1Qb3J0IC0gVGhlIGVtdWxhdG9yIHBvcnQgdG8gYmUgc2V0LlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5zZXRFbXVsYXRvclBvcnQgPSBmdW5jdGlvbiAoZW1Qb3J0KSB7XG4gIHRoaXMuZW11bGF0b3JQb3J0ID0gZW1Qb3J0O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGlkZW50aWZpZXIgb2YgdGhlIGN1cnJlbnQgZGV2aWNlIChfdGhpcy5jdXJEZXZpY2VJZF8pLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAtIFRoZSBkZXZpY2UgaWRlbnRpZmllci5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuc2V0RGV2aWNlSWQgPSBmdW5jdGlvbiAoZGV2aWNlSWQpIHtcbiAgbG9nLmRlYnVnKGBTZXR0aW5nIGRldmljZSBpZCB0byAke2RldmljZUlkfWApO1xuICB0aGlzLmN1ckRldmljZUlkID0gZGV2aWNlSWQ7XG4gIGxldCBhcmdzSGFzRGV2aWNlID0gdGhpcy5leGVjdXRhYmxlLmRlZmF1bHRBcmdzLmluZGV4T2YoJy1zJyk7XG4gIGlmIChhcmdzSGFzRGV2aWNlICE9PSAtMSkge1xuICAgIC8vIHJlbW92ZSB0aGUgb2xkIGRldmljZSBpZCBmcm9tIHRoZSBhcmd1bWVudHNcbiAgICB0aGlzLmV4ZWN1dGFibGUuZGVmYXVsdEFyZ3Muc3BsaWNlKGFyZ3NIYXNEZXZpY2UsIDIpO1xuICB9XG4gIHRoaXMuZXhlY3V0YWJsZS5kZWZhdWx0QXJncy5wdXNoKCctcycsIGRldmljZUlkKTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSB0aGUgY3VycmVudCBkZXZpY2Ugb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7RGV2aWNlfSBkZXZpY2VPYmogLSBUaGUgZGV2aWNlIG9iamVjdCB0byBiZSBzZXQuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLnNldERldmljZSA9IGZ1bmN0aW9uIChkZXZpY2VPYmopIHtcbiAgbGV0IGRldmljZUlkID0gZGV2aWNlT2JqLnVkaWQ7XG4gIGxldCBlbVBvcnQgPSB0aGlzLmdldFBvcnRGcm9tRW11bGF0b3JTdHJpbmcoZGV2aWNlSWQpO1xuICB0aGlzLnNldEVtdWxhdG9yUG9ydChlbVBvcnQpO1xuICB0aGlzLnNldERldmljZUlkKGRldmljZUlkKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBvYmplY3QgZm9yIHRoZSBjdXJyZW50bHkgcnVubmluZyBlbXVsYXRvci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXZkTmFtZSAtIEVtdWxhdG9yIG5hbWUuXG4gKiBAcmV0dXJuIHs/RGV2aWNlfSBDdXJyZW50bHkgcnVubmluZyBlbXVsYXRvciBvciBfbnVsbF8uXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldFJ1bm5pbmdBVkQgPSBhc3luYyBmdW5jdGlvbiAoYXZkTmFtZSkge1xuICB0cnkge1xuICAgIGxvZy5kZWJ1ZyhgVHJ5aW5nIHRvIGZpbmQgJHthdmROYW1lfSBlbXVsYXRvcmApO1xuICAgIGxldCBlbXVsYXRvcnMgPSBhd2FpdCB0aGlzLmdldENvbm5lY3RlZEVtdWxhdG9ycygpO1xuICAgIGZvciAobGV0IGVtdWxhdG9yIG9mIGVtdWxhdG9ycykge1xuICAgICAgdGhpcy5zZXRFbXVsYXRvclBvcnQoZW11bGF0b3IucG9ydCk7XG4gICAgICBsZXQgcnVubmluZ0FWRE5hbWUgPSBhd2FpdCB0aGlzLnNlbmRUZWxuZXRDb21tYW5kKFwiYXZkIG5hbWVcIik7XG4gICAgICBpZiAoYXZkTmFtZSA9PT0gcnVubmluZ0FWRE5hbWUpIHtcbiAgICAgICAgbG9nLmRlYnVnKGBGb3VuZCBlbXVsYXRvciAke2F2ZE5hbWV9IGluIHBvcnQgJHtlbXVsYXRvci5wb3J0fWApO1xuICAgICAgICB0aGlzLnNldERldmljZUlkKGVtdWxhdG9yLnVkaWQpO1xuICAgICAgICByZXR1cm4gZW11bGF0b3I7XG4gICAgICB9XG4gICAgfVxuICAgIGxvZy5kZWJ1ZyhgRW11bGF0b3IgJHthdmROYW1lfSBub3QgcnVubmluZ2ApO1xuICAgIHJldHVybiBudWxsO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBnZXR0aW5nIEFWRC4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCB0aGUgb2JqZWN0IGZvciB0aGUgY3VycmVudGx5IHJ1bm5pbmcgZW11bGF0b3IuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF2ZE5hbWUgLSBFbXVsYXRvciBuYW1lLlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRNcyBbMjAwMDBdIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIG1pbGxpc2Vjb25kc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gd2FpdCB1bnRpbCBhdCBsZWFzdCBvbmUgcnVubmluZyBBVkQgb2JqZWN0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyBkZXRlY3RlZC5cbiAqIEByZXR1cm4gez9EZXZpY2V9IEN1cnJlbnRseSBydW5uaW5nIGVtdWxhdG9yIG9yIF9udWxsXy5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBubyBkZXZpY2UgaGFzIGJlZW4gZGV0ZWN0ZWQgd2l0aGluIHRoZSB0aW1lb3V0LlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRSdW5uaW5nQVZEV2l0aFJldHJ5ID0gYXN5bmMgZnVuY3Rpb24gKGF2ZE5hbWUsIHRpbWVvdXRNcyA9IDIwMDAwKSB7XG4gIGxldCBydW5uaW5nQXZkO1xuICB0cnkge1xuICAgIGF3YWl0IHdhaXRGb3JDb25kaXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgcnVubmluZ0F2ZCA9IGF3YWl0IHRoaXMuZ2V0UnVubmluZ0FWRChhdmROYW1lLnJlcGxhY2UoJ0AnLCAnJykpO1xuICAgICAgcmV0dXJuIHJ1bm5pbmdBdmQ7XG4gICAgfSwge1xuICAgICAgd2FpdE1zOiB0aW1lb3V0TXMsXG4gICAgICBpbnRlcnZhbE1zOiAyMDAsXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGdldHRpbmcgQVZEIHdpdGggcmV0cnkuIE9yaWdpbmFsIGVycm9yOiAke2UubWVzc2FnZX1gKTtcbiAgfVxuICByZXR1cm4gcnVubmluZ0F2ZDtcbn07XG5cbi8qKlxuICogU2h1dGRvd24gYWxsIHJ1bm5pbmcgZW11bGF0b3JzIGJ5IGtpbGxpbmcgdGhlaXIgcHJvY2Vzc2VzLlxuICpcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBraWxsaW5nIHRvb2wgcmV0dXJuZWQgbm9uLXplcm8gcmV0dXJuIGNvZGUuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmtpbGxBbGxFbXVsYXRvcnMgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIGxldCBjbWQsIGFyZ3M7XG4gIGlmIChzeXN0ZW0uaXNXaW5kb3dzKCkpIHtcbiAgICBjbWQgPSAnVEFTS0tJTEwnO1xuICAgIGFyZ3MgPSBbJ1RBU0tLSUxMJywgJy9JTScsICdlbXVsYXRvci5leGUnXTtcbiAgfSBlbHNlIHtcbiAgICBjbWQgPSAnL3Vzci9iaW4va2lsbGFsbCc7XG4gICAgYXJncyA9IFsnLW0nLCAnZW11bGF0b3IqJ107XG4gIH1cbiAgdHJ5IHtcbiAgICBhd2FpdCBleGVjKGNtZCwgYXJncyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGtpbGxpbmcgZW11bGF0b3JzLiBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gIH1cbn07XG5cbi8qKlxuICogS2lsbCBlbXVsYXRvciB3aXRoIHRoZSBnaXZlbiBuYW1lLiBObyBlcnJvclxuICogaXMgdGhyb3duIGlzIGdpdmVuIGF2ZCBkb2VzIG5vdCBleGlzdC9pcyBub3QgcnVubmluZy5cbiAqXG4gKiBAcGFyYW0gez9zdHJpbmd9IGF2ZE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZW11bGF0b3IgdG8gYmUga2lsbGVkLiBJZiBlbXB0eSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBjdXJyZW50IGVtdWxhdG9yIHdpbGwgYmUga2lsbGVkLlxuICogQHBhcmFtIHs/bnVtYmVyfSB0aW1lb3V0IFs2MDAwMF0gLSBUaGUgYW1vdW50IG9mIHRpbWUgdG8gd2FpdCBiZWZvcmUgdGhyb3dpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW4gZXhjZXB0aW9uIGFib3V0IHVuc3VjY2Vzc2Z1bCBraWxsaW5nXG4gKiBAcmV0dXJuIHtib29sZWFufSAtIFRydWUgaWYgdGhlIGVtdWxhdG9yIHdhcyBraWxsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGVyZSB3YXMgYSBmYWlsdXJlIGJ5IGtpbGxpbmcgdGhlIGVtdWxhdG9yXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmtpbGxFbXVsYXRvciA9IGFzeW5jIGZ1bmN0aW9uIChhdmROYW1lID0gbnVsbCwgdGltZW91dCA9IDYwMDAwKSB7XG4gIGlmICh1dGlsLmhhc1ZhbHVlKGF2ZE5hbWUpKSB7XG4gICAgbG9nLmRlYnVnKGBLaWxsaW5nIGF2ZCAnJHthdmROYW1lfSdgKTtcbiAgICBjb25zdCBkZXZpY2UgPSBhd2FpdCB0aGlzLmdldFJ1bm5pbmdBVkQoYXZkTmFtZSk7XG4gICAgaWYgKCFkZXZpY2UpIHtcbiAgICAgIGxvZy5pbmZvKGBObyBhdmQgd2l0aCBuYW1lICcke2F2ZE5hbWV9JyBydW5uaW5nLiBTa2lwcGluZyBraWxsIHN0ZXAuYCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGtpbGxpbmcgdGhlIGN1cnJlbnQgYXZkXG4gICAgbG9nLmRlYnVnKGBLaWxsaW5nIGF2ZCB3aXRoIGlkICcke3RoaXMuY3VyRGV2aWNlSWR9J2ApO1xuICAgIGlmICghYXdhaXQgdGhpcy5pc0VtdWxhdG9yQ29ubmVjdGVkKCkpIHtcbiAgICAgIGxvZy5kZWJ1ZyhgRW11bGF0b3Igd2l0aCBpZCAnJHt0aGlzLmN1ckRldmljZUlkfScgbm90IGNvbm5lY3RlZC4gU2tpcHBpbmcga2lsbCBzdGVwYCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGF3YWl0IHRoaXMuYWRiRXhlYyhbJ2VtdScsICdraWxsJ10pO1xuICBsb2cuZGVidWcoYFdhaXRpbmcgdXAgdG8gJHt0aW1lb3V0fW1zIHVudGlsIHRoZSBlbXVsYXRvciAnJHthdmROYW1lID8gYXZkTmFtZSA6IHRoaXMuY3VyRGV2aWNlSWR9JyBpcyBraWxsZWRgKTtcbiAgdHJ5IHtcbiAgICBhd2FpdCB3YWl0Rm9yQ29uZGl0aW9uKGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1dGlsLmhhc1ZhbHVlKGF2ZE5hbWUpXG4gICAgICAgICAgPyAhYXdhaXQgdGhpcy5nZXRSdW5uaW5nQVZEKGF2ZE5hbWUpXG4gICAgICAgICAgOiAhYXdhaXQgdGhpcy5pc0VtdWxhdG9yQ29ubmVjdGVkKCk7XG4gICAgICB9IGNhdGNoIChpZ24pIHt9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSwge1xuICAgICAgd2FpdE1zOiB0aW1lb3V0LFxuICAgICAgaW50ZXJ2YWxNczogMjAwMCxcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGVtdWxhdG9yICcke2F2ZE5hbWUgPyBhdmROYW1lIDogdGhpcy5jdXJEZXZpY2VJZH0nIGlzIHN0aWxsIHJ1bm5pbmcgYWZ0ZXIgYmVpbmcga2lsbGVkICR7dGltZW91dH1tcyBhZ29gKTtcbiAgfVxuICBsb2cuaW5mbyhgU3VjY2Vzc2Z1bGx5IGtpbGxlZCB0aGUgJyR7YXZkTmFtZSA/IGF2ZE5hbWUgOiB0aGlzLmN1ckRldmljZUlkfScgZW11bGF0b3JgKTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIFN0YXJ0IGFuIGVtdWxhdG9yIHdpdGggZ2l2ZW4gcGFyYW1ldGVycyBhbmQgd2FpdCB1bnRpbCBpdCBpcyBmdWxsIHN0YXJ0ZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF2ZE5hbWUgLSBUaGUgbmFtZSBvZiBhbiBleGlzdGluZyBlbXVsYXRvci5cbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz58c3RyaW5nfSBhdmRBcmdzIC0gQWRkaXRpb25hbCBlbXVsYXRvciBjb21tYW5kIGxpbmUgYXJndW1lbnQuXG4gKiBAcGFyYW0gez9zdHJpbmd9IGxhbmd1YWdlIC0gRW11bGF0b3Igc3lzdGVtIGxhbmd1YWdlLlxuICogQHBhcmFtIHs/Y29udHJ5fSBjb3VudHJ5IC0gRW11bGF0b3Igc3lzdGVtIGNvdW50cnkuXG4gKiBAcGFyYW0ge251bWJlcn0gYXZkTGF1bmNoVGltZW91dCBbNjAwMDBdIC0gRW11bGF0b3Igc3RhcnR1cCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSByZXRyeVRpbWVzIFsxXSAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBzdGFydHVwIHJldHJpZXMuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGVtdWxhdG9yIGZhaWxzIHRvIHN0YXJ0IHdpdGhpbiB0aGUgZ2l2ZW4gdGltZW91dC5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMubGF1bmNoQVZEID0gYXN5bmMgZnVuY3Rpb24gKGF2ZE5hbWUsIGF2ZEFyZ3MsIGxhbmd1YWdlLCBjb3VudHJ5LFxuICBhdmRMYXVuY2hUaW1lb3V0ID0gNjAwMDAsIGF2ZFJlYWR5VGltZW91dCA9IDYwMDAwLCByZXRyeVRpbWVzID0gMSkge1xuICBsb2cuZGVidWcoYExhdW5jaGluZyBFbXVsYXRvciB3aXRoIEFWRCAke2F2ZE5hbWV9LCBsYXVuY2hUaW1lb3V0IGAgK1xuICAgICAgICAgICAgYCR7YXZkTGF1bmNoVGltZW91dH1tcyBhbmQgcmVhZHlUaW1lb3V0ICR7YXZkUmVhZHlUaW1lb3V0fW1zYCk7XG4gIGxldCBlbXVsYXRvckJpbmFyeVBhdGggPSBhd2FpdCB0aGlzLmdldFNka0JpbmFyeVBhdGgoXCJlbXVsYXRvclwiKTtcbiAgaWYgKGF2ZE5hbWVbMF0gPT09IFwiQFwiKSB7XG4gICAgYXZkTmFtZSA9IGF2ZE5hbWUuc3Vic3RyKDEpO1xuICB9XG4gIGF3YWl0IHRoaXMuY2hlY2tBdmRFeGlzdChhdmROYW1lKTtcbiAgbGV0IGxhdW5jaEFyZ3MgPSBbXCItYXZkXCIsIGF2ZE5hbWVdO1xuICBpZiAoXy5pc1N0cmluZyhsYW5ndWFnZSkpIHtcbiAgICBsb2cuZGVidWcoYFNldHRpbmcgQW5kcm9pZCBEZXZpY2UgTGFuZ3VhZ2UgdG8gJHtsYW5ndWFnZX1gKTtcbiAgICBsYXVuY2hBcmdzLnB1c2goXCItcHJvcFwiLCBgcGVyc2lzdC5zeXMubGFuZ3VhZ2U9JHtsYW5ndWFnZS50b0xvd2VyQ2FzZSgpfWApO1xuICB9XG4gIGlmIChfLmlzU3RyaW5nKGNvdW50cnkpKSB7XG4gICAgbG9nLmRlYnVnKGBTZXR0aW5nIEFuZHJvaWQgRGV2aWNlIENvdW50cnkgdG8gJHtjb3VudHJ5fWApO1xuICAgIGxhdW5jaEFyZ3MucHVzaChcIi1wcm9wXCIsIGBwZXJzaXN0LnN5cy5jb3VudHJ5PSR7Y291bnRyeS50b1VwcGVyQ2FzZSgpfWApO1xuICB9XG4gIGxldCBsb2NhbGU7XG4gIGlmIChfLmlzU3RyaW5nKGxhbmd1YWdlKSAmJiBfLmlzU3RyaW5nKGNvdW50cnkpKSB7XG4gICAgbG9jYWxlID0gbGFuZ3VhZ2UudG9Mb3dlckNhc2UoKSArIFwiLVwiICsgY291bnRyeS50b1VwcGVyQ2FzZSgpO1xuICB9IGVsc2UgaWYgKF8uaXNTdHJpbmcobGFuZ3VhZ2UpKSB7XG4gICAgbG9jYWxlID0gbGFuZ3VhZ2UudG9Mb3dlckNhc2UoKTtcbiAgfSBlbHNlIGlmIChfLmlzU3RyaW5nKGNvdW50cnkpKSB7XG4gICAgbG9jYWxlID0gY291bnRyeTtcbiAgfVxuICBpZiAoXy5pc1N0cmluZyhsb2NhbGUpKSB7XG4gICAgbG9nLmRlYnVnKGBTZXR0aW5nIEFuZHJvaWQgRGV2aWNlIExvY2FsZSB0byAke2xvY2FsZX1gKTtcbiAgICBsYXVuY2hBcmdzLnB1c2goXCItcHJvcFwiLCBgcGVyc2lzdC5zeXMubG9jYWxlPSR7bG9jYWxlfWApO1xuICB9XG4gIGlmICghXy5pc0VtcHR5KGF2ZEFyZ3MpKSB7XG4gICAgbGF1bmNoQXJncy5wdXNoKC4uLihfLmlzQXJyYXkoYXZkQXJncykgPyBhdmRBcmdzIDogYXZkQXJncy5zcGxpdCgnICcpKSk7XG4gIH1cbiAgbG9nLmRlYnVnKGBSdW5uaW5nICcke2VtdWxhdG9yQmluYXJ5UGF0aH0nIHdpdGggYXJnczogJHtKU09OLnN0cmluZ2lmeShsYXVuY2hBcmdzKX1gKTtcbiAgbGV0IHByb2MgPSBuZXcgU3ViUHJvY2VzcyhlbXVsYXRvckJpbmFyeVBhdGgsIGxhdW5jaEFyZ3MpO1xuICBhd2FpdCBwcm9jLnN0YXJ0KDApO1xuICBwcm9jLm9uKCdvdXRwdXQnLCAoc3Rkb3V0LCBzdGRlcnIpID0+IHtcbiAgICBmb3IgKGxldCBsaW5lIG9mIChzdGRvdXQgfHwgc3RkZXJyIHx8ICcnKS5zcGxpdCgnXFxuJykuZmlsdGVyKEJvb2xlYW4pKSB7XG4gICAgICBsb2cuaW5mbyhgW0FWRCBPVVRQVVRdICR7bGluZX1gKTtcbiAgICB9XG4gIH0pO1xuICBwcm9jLm9uKCdkaWUnLCAoY29kZSwgc2lnbmFsKSA9PiB7XG4gICAgbG9nLndhcm4oYEVtdWxhdG9yIGF2ZCAke2F2ZE5hbWV9IGV4aXRlZCB3aXRoIGNvZGUgJHtjb2RlfSR7c2lnbmFsID8gYCwgc2lnbmFsICR7c2lnbmFsfWAgOiAnJ31gKTtcbiAgfSk7XG4gIGF3YWl0IHJldHJ5KHJldHJ5VGltZXMsIHRoaXMuZ2V0UnVubmluZ0FWRFdpdGhSZXRyeS5iaW5kKHRoaXMpLCBhdmROYW1lLCBhdmRMYXVuY2hUaW1lb3V0KTtcbiAgYXdhaXQgdGhpcy53YWl0Rm9yRW11bGF0b3JSZWFkeShhdmRSZWFkeVRpbWVvdXQpO1xuICByZXR1cm4gcHJvYztcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQURCVmVyc2lvblxuICogQHByb3BlcnR5IHtzdHJpbmd9IHZlcnNpb25TdHJpbmcgLSBBREIgdmVyc2lvbiBhcyBhIHN0cmluZy5cbiAqIEBwcm9wZXJ0eSB7ZmxvYXR9IHZlcnNpb25GbG9hdCAtIFZlcnNpb24gbnVtYmVyIGFzIGZsb2F0IHZhbHVlICh1c2VmdWwgZm9yIGNvbXBhcmlzb24pLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1ham9yIC0gTWFqb3IgdmVyc2lvbiBudW1iZXIuXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWlub3IgLSBNaW5vciB2ZXJzaW9uIG51bWJlci5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwYXRjaCAtIFBhdGNoIHZlcnNpb24gbnVtYmVyLlxuICovXG5cbi8qKlxuICogR2V0IHRoZSBhZGIgdmVyc2lvbi4gVGhlIHJlc3VsdCBvZiB0aGlzIG1ldGhvZCBpcyBjYWNoZWQuXG4gKlxuICogQHJldHVybiB7QURCVmVyc2lvbn0gVGhlIGN1cnJlbnQgYWRiIHZlcnNpb24uXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgaXQgaXMgbm90IHBvc3NpYmxlIHRvIHBhcnNlIGFkYiB2ZXJzaW9uLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRBZGJWZXJzaW9uID0gXy5tZW1vaXplKGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBsZXQgYWRiVmVyc2lvbiA9IChhd2FpdCB0aGlzLmFkYkV4ZWMoJ3ZlcnNpb24nKSlcbiAgICAgIC5yZXBsYWNlKC9BbmRyb2lkXFxzRGVidWdcXHNCcmlkZ2VcXHN2ZXJzaW9uXFxzKFtcXGRcXC5dKilbXFxzXFx3XFwtXSovLCBcIiQxXCIpO1xuICAgIGxldCBwYXJ0cyA9IGFkYlZlcnNpb24uc3BsaXQoJy4nKTtcbiAgICByZXR1cm4ge1xuICAgICAgdmVyc2lvblN0cmluZzogYWRiVmVyc2lvbixcbiAgICAgIHZlcnNpb25GbG9hdDogcGFyc2VGbG9hdChhZGJWZXJzaW9uKSxcbiAgICAgIG1ham9yOiBwYXJzZUludChwYXJ0c1swXSwgMTApLFxuICAgICAgbWlub3I6IHBhcnNlSW50KHBhcnRzWzFdLCAxMCksXG4gICAgICBwYXRjaDogcGFydHNbMl0gPyBwYXJzZUludChwYXJ0c1syXSwgMTApIDogdW5kZWZpbmVkLFxuICAgIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGdldHRpbmcgYWRiIHZlcnNpb24uIE9yaWdpbmFsIGVycm9yOiAnJHtlLm1lc3NhZ2V9JzsgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgU3RkZXJyOiAnJHsoZS5zdGRlcnIgfHwgJycpLnRyaW0oKX0nOyBDb2RlOiAnJHtlLmNvZGV9J2ApO1xuICB9XG59KTtcblxuLyoqXG4gKiBDaGVjayBpZiBnaXZlbiBlbXVsYXRvciBleGlzdHMgaW4gdGhlIGxpc3Qgb2YgYXZhaWxhYmxlIGF2ZHMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF2ZE5hbWUgLSBUaGUgbmFtZSBvZiBlbXVsYXRvciB0byB2ZXJpZnkgZm9yIGV4aXN0ZW5jZS5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZW11bGF0b3Igd2l0aCBnaXZlbiBuYW1lIGRvZXMgbm90IGV4aXN0LlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5jaGVja0F2ZEV4aXN0ID0gYXN5bmMgZnVuY3Rpb24gKGF2ZE5hbWUpIHtcbiAgbGV0IGNtZCwgcmVzdWx0O1xuICB0cnkge1xuICAgIGNtZCA9IGF3YWl0IHRoaXMuZ2V0U2RrQmluYXJ5UGF0aCgnZW11bGF0b3InKTtcbiAgICByZXN1bHQgPSBhd2FpdCBleGVjKGNtZCwgWyctbGlzdC1hdmRzJ10pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbGV0IHVua25vd25PcHRpb25FcnJvciA9IG5ldyBSZWdFeHAoXCJ1bmtub3duIG9wdGlvbjogLWxpc3QtYXZkc1wiLCBcImlcIikudGVzdChlLnN0ZGVycik7XG4gICAgaWYgKCF1bmtub3duT3B0aW9uRXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZXhlY3V0aW5nIGNoZWNrQXZkRXhpc3QuIE9yaWdpbmFsIGVycm9yOiAnJHtlLm1lc3NhZ2V9JzsgYCArXG4gICAgICAgICAgICAgICAgICAgICAgYFN0ZGVycjogJyR7KGUuc3RkZXJyIHx8ICcnKS50cmltKCl9JzsgQ29kZTogJyR7ZS5jb2RlfSdgKTtcblxuICAgIH1cbiAgICBjb25zdCBzZGtWZXJzaW9uID0gYXdhaXQgZ2V0U2RrVG9vbHNWZXJzaW9uKCk7XG4gICAgbGV0IGJpbmFyeU5hbWUgPSAnYW5kcm9pZCc7XG4gICAgaWYgKHNka1ZlcnNpb24pIHtcbiAgICAgIGlmIChzZGtWZXJzaW9uLm1ham9yID49IDI1KSB7XG4gICAgICAgIGJpbmFyeU5hbWUgPSAnYXZkbWFuYWdlcic7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZy53YXJuKGBEZWZhdWx0aW5nIGJpbmFyeSBuYW1lIHRvICcke2JpbmFyeU5hbWV9JywgYmVjYXVzZSBTREsgdmVyc2lvbiBjYW5ub3QgYmUgcGFyc2VkYCk7XG4gICAgfVxuICAgIC8vIElmIC1saXN0LWF2ZHMgb3B0aW9uIGlzIG5vdCBhdmFpbGFibGUsIHVzZSBhbmRyb2lkIGNvbW1hbmQgYXMgYW4gYWx0ZXJuYXRpdmVcbiAgICBjbWQgPSBhd2FpdCB0aGlzLmdldFNka0JpbmFyeVBhdGgoYmluYXJ5TmFtZSk7XG4gICAgcmVzdWx0ID0gYXdhaXQgZXhlYyhjbWQsIFsnbGlzdCcsICdhdmQnLCAnLWMnXSk7XG4gIH1cbiAgaWYgKHJlc3VsdC5zdGRvdXQuaW5kZXhPZihhdmROYW1lKSA9PT0gLTEpIHtcbiAgICBsZXQgZXhpc3RpbmdzID0gYCgke3Jlc3VsdC5zdGRvdXQudHJpbSgpLnJlcGxhY2UoL1tcXG5dL2csICcpLCAoJyl9KWA7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBBdmQgJyR7YXZkTmFtZX0nIGlzIG5vdCBhdmFpbGFibGUuIHBsZWFzZSBzZWxlY3QgeW91ciBhdmQgbmFtZSBmcm9tIG9uZSBvZiB0aGVzZTogJyR7ZXhpc3RpbmdzfSdgKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgY3VycmVudCBlbXVsYXRvciBpcyByZWFkeSB0byBhY2NlcHQgZnVydGhlciBjb21tYW5kcyAoYm9vdGluZyBjb21wbGV0ZWQpLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0TXMgWzIwMDAwXSAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZW11bGF0b3IgaXMgbm90IHJlYWR5IHdpdGhpbiB0aGUgZ2l2ZW4gdGltZW91dC5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMud2FpdEZvckVtdWxhdG9yUmVhZHkgPSBhc3luYyBmdW5jdGlvbiAodGltZW91dE1zID0gMjAwMDApIHtcbiAgdHJ5IHtcbiAgICBhd2FpdCB3YWl0Rm9yQ29uZGl0aW9uKGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghKGF3YWl0IHRoaXMuc2hlbGwoWydnZXRwcm9wJywgJ2luaXQuc3ZjLmJvb3RhbmltJ10pKS5pbmNsdWRlcygnc3RvcHBlZCcpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvbWV0aW1lcyB0aGUgcGFja2FnZSBtYW5hZ2VyIHNlcnZpY2UgbWlnaHQgc3RpbGwgYmVpbmcgaW5pdGlhbGl6ZWRcbiAgICAgICAgLy8gb24gc2xvdyBzeXN0ZW1zIGV2ZW4gYWZ0ZXIgZW11bGF0b3IgYm9vdGluZyBpcyBjb21wbGV0ZWQuXG4gICAgICAgIC8vIFRoZSB1c3VhbCBvdXRwdXQgb2YgYHBtIGdldC1pbnN0YWxsLWxvY2F0aW9uYCBjb21tYW5kIGxvb2tzIGxpa2UgYDBbYXV0b11gXG4gICAgICAgIHJldHVybiAvXFxkK1xcW1xcdytcXF0vLnRlc3QoYXdhaXQgdGhpcy5zaGVsbChbJ3BtJywgJ2dldC1pbnN0YWxsLWxvY2F0aW9uJ10pKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBsb2cuZGVidWcoYFdhaXRpbmcgZm9yIGVtdWxhdG9yIHN0YXJ0dXAuIEludGVybWVkaWF0ZSBlcnJvcjogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHdhaXRNczogdGltZW91dE1zLFxuICAgICAgaW50ZXJ2YWxNczogMzAwMCxcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRW11bGF0b3IgaXMgbm90IHJlYWR5IHdpdGhpbiAke3RpbWVvdXRNc31tc2ApO1xuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBjdXJyZW50IGRldmljZSBpcyByZWFkeSB0byBhY2NlcHQgZnVydGhlciBjb21tYW5kcyAoYm9vdGluZyBjb21wbGV0ZWQpLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBhcHBEZXZpY2VSZWFkeVRpbWVvdXQgWzMwXSAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBzZWNvbmRzIHRvIHdhaXQuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGRldmljZSBpcyBub3QgcmVhZHkgd2l0aGluIHRoZSBnaXZlbiB0aW1lb3V0LlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy53YWl0Rm9yRGV2aWNlID0gYXN5bmMgZnVuY3Rpb24gKGFwcERldmljZVJlYWR5VGltZW91dCA9IDMwKSB7XG4gIHRoaXMuYXBwRGV2aWNlUmVhZHlUaW1lb3V0ID0gYXBwRGV2aWNlUmVhZHlUaW1lb3V0O1xuICBjb25zdCByZXRyaWVzID0gMztcbiAgY29uc3QgdGltZW91dCA9IHBhcnNlSW50KHRoaXMuYXBwRGV2aWNlUmVhZHlUaW1lb3V0LCAxMCkgLyByZXRyaWVzICogMTAwMDtcbiAgYXdhaXQgcmV0cnkocmV0cmllcywgYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmFkYkV4ZWMoJ3dhaXQtZm9yLWRldmljZScsIHt0aW1lb3V0fSk7XG4gICAgICBhd2FpdCB0aGlzLnBpbmcoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBhd2FpdCB0aGlzLnJlc3RhcnRBZGIoKTtcbiAgICAgIGF3YWl0IHRoaXMuZ2V0Q29ubmVjdGVkRGV2aWNlcygpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBpbiB3YWl0aW5nIGZvciBkZXZpY2UuIE9yaWdpbmFsIGVycm9yOiAnJHtlLm1lc3NhZ2V9Jy4gYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgYFJldHJ5aW5nIGJ5IHJlc3RhcnRpbmcgQURCYCk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogUmVib290IHRoZSBjdXJyZW50IGRldmljZSBhbmQgd2FpdCB1bnRpbCBpdCBpcyBjb21wbGV0ZWQuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHJldHJpZXMgW0RFRkFVTFRfQURCX1JFQk9PVF9SRVRSSUVTXSAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiByZWJvb3QgcmV0cmllcy5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZGV2aWNlIGZhaWxlZCB0byByZWJvb3QgYW5kIG51bWJlciBvZiByZXRyaWVzIGlzIGV4Y2VlZGVkLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5yZWJvb3QgPSBhc3luYyBmdW5jdGlvbiAocmV0cmllcyA9IERFRkFVTFRfQURCX1JFQk9PVF9SRVRSSUVTKSB7XG4gIHRyeSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuc2hlbGwoWydzdG9wJ10pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyci5tZXNzYWdlLmluZGV4T2YoJ211c3QgYmUgcm9vdCcpID09PSAtMSkge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgICAvLyB0aGlzIGRldmljZSBuZWVkcyBhZGIgdG8gYmUgcnVubmluZyBhcyByb290IHRvIHN0b3AuXG4gICAgICAvLyBzbyB0cnkgdG8gcmVzdGFydCB0aGUgZGFlbW9uXG4gICAgICBsb2cuZGVidWcoJ0RldmljZSByZXF1aXJlcyBhZGIgdG8gYmUgcnVubmluZyBhcyByb290IGluIG9yZGVyIHRvIHJlYm9vdC4gUmVzdGFydGluZyBkYWVtb24nKTtcbiAgICAgIGF3YWl0IHRoaXMucm9vdCgpO1xuICAgICAgYXdhaXQgdGhpcy5zaGVsbChbJ3N0b3AnXSk7XG4gICAgfVxuICAgIGF3YWl0IEIuZGVsYXkoMjAwMCk7IC8vIGxldCB0aGUgZW11IGZpbmlzaCBzdG9wcGluZztcbiAgICBhd2FpdCB0aGlzLnNldERldmljZVByb3BlcnR5KCdzeXMuYm9vdF9jb21wbGV0ZWQnLCAwKTtcbiAgICBhd2FpdCB0aGlzLnNoZWxsKFsnc3RhcnQnXSk7XG4gICAgYXdhaXQgcmV0cnlJbnRlcnZhbChyZXRyaWVzLCAxMDAwLCBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgYm9vdGVkID0gYXdhaXQgdGhpcy5nZXREZXZpY2VQcm9wZXJ0eSgnc3lzLmJvb3RfY29tcGxldGVkJyk7XG4gICAgICBpZiAoYm9vdGVkID09PSAnMScpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0aGUgc3RhY2sgdHJhY2UsIHNvIG5vIGxvZy5lcnJvckFuZFRocm93XG4gICAgICAgIGxldCBtc2cgPSAnV2FpdGluZyBmb3IgcmVib290LiBUaGlzIHRha2VzIHRpbWUnO1xuICAgICAgICBsb2cuZGVidWcobXNnKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZmluYWxseSB7XG4gICAgYXdhaXQgdGhpcy51bnJvb3QoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTd2l0Y2ggYWRiIHNlcnZlciB0byByb290IG1vZGUuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBvZiB0aGUgc3dpdGNoIHdhcyBzdWNjZXNzZnVsIG9yIGZhbHNlXG4gKiAgICAgICAgICAgICAgICAgICBpZiB0aGUgc3dpdGNoIGZhaWxlZC5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMucm9vdCA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBsZXQge3N0ZG91dH0gPSBhd2FpdCBleGVjKHRoaXMuZXhlY3V0YWJsZS5wYXRoLCBbJ3Jvb3QnXSk7XG5cbiAgICAvLyBvbiByZWFsIGRldmljZXMgaW4gc29tZSBzaXR1YXRpb25zIHdlIGdldCBhbiBlcnJvciBpbiB0aGUgc3Rkb3V0XG4gICAgaWYgKHN0ZG91dCAmJiBzdGRvdXQuaW5kZXhPZignYWRiZCBjYW5ub3QgcnVuIGFzIHJvb3QnKSAhPT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihzdGRvdXQudHJpbSgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgbG9nLndhcm4oYFVuYWJsZSB0byByb290IGFkYiBkYWVtb246ICcke2Vyci5tZXNzYWdlfScuIENvbnRpbnVpbmdgKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICogU3dpdGNoIGFkYiBzZXJ2ZXIgdG8gbm9uLXJvb3QgbW9kZS5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIG9mIHRoZSBzd2l0Y2ggd2FzIHN1Y2Nlc3NmdWwgb3IgZmFsc2VcbiAqICAgICAgICAgICAgICAgICAgIGlmIHRoZSBzd2l0Y2ggZmFpbGVkLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy51bnJvb3QgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgYXdhaXQgZXhlYyh0aGlzLmV4ZWN1dGFibGUucGF0aCwgWyd1bnJvb3QnXSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGxvZy53YXJuKGBVbmFibGUgdG8gdW5yb290IGFkYiBkYWVtb246ICcke2Vyci5tZXNzYWdlfScuIENvbnRpbnVpbmdgKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICogVmVyaWZ5IHdoZXRoZXIgYSByZW1vdGUgcGF0aCBleGlzdHMgb24gdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZW1vdGVQYXRoIC0gVGhlIHJlbW90ZSBwYXRoIHRvIHZlcmlmeS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGdpdmVuIHBhdGggZXhpc3RzIG9uIHRoZSBkZXZpY2UuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmZpbGVFeGlzdHMgPSBhc3luYyBmdW5jdGlvbiAocmVtb3RlUGF0aCkge1xuICBsZXQgZmlsZXMgPSBhd2FpdCB0aGlzLmxzKHJlbW90ZVBhdGgpO1xuICByZXR1cm4gZmlsZXMubGVuZ3RoID4gMDtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBvdXRwdXQgb2YgX2xzXyBjb21tYW5kIG9uIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVtb3RlUGF0aCAtIFRoZSByZW1vdGUgcGF0aCAodGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBfbHNfIGNvbW1hbmQpLlxuICogQHBhcmFtIHtBcnJheS48U3RyaW5nPn0gb3B0cyBbW11dIC0gQWRkaXRpb25hbCBfbHNfIG9wdGlvbnMuXG4gKiBAcmV0dXJuIHtBcnJheS48U3RyaW5nPn0gVGhlIF9sc18gb3V0cHV0IGFzIGFuIGFycmF5IG9mIHNwbGl0IGxpbmVzLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIEFuIGVtcHR5IGFycmF5IGlzIHJldHVybmVkIG9mIHRoZSBnaXZlbiBfcmVtb3RlUGF0aF9cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBkb2VzIG5vdCBleGlzdC5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMubHMgPSBhc3luYyBmdW5jdGlvbiAocmVtb3RlUGF0aCwgb3B0cyA9IFtdKSB7XG4gIHRyeSB7XG4gICAgbGV0IGFyZ3MgPSBbJ2xzJywgLi4ub3B0cywgcmVtb3RlUGF0aF07XG4gICAgbGV0IHN0ZG91dCA9IGF3YWl0IHRoaXMuc2hlbGwoYXJncyk7XG4gICAgbGV0IGxpbmVzID0gc3Rkb3V0LnNwbGl0KFwiXFxuXCIpO1xuICAgIHJldHVybiBsaW5lcy5tYXAoKGwpID0+IGwudHJpbSgpKVxuICAgICAgLmZpbHRlcihCb29sZWFuKVxuICAgICAgLmZpbHRlcigobCkgPT4gbC5pbmRleE9mKFwiTm8gc3VjaCBmaWxlXCIpID09PSAtMSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIubWVzc2FnZS5pbmRleE9mKCdObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5JykgPT09IC0xKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgdGhlIHNpemUgb2YgdGhlIHBhcnRpY3VsYXIgZmlsZSBsb2NhdGVkIG9uIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVtb3RlUGF0aCAtIFRoZSByZW1vdGUgcGF0aCB0byB0aGUgZmlsZS5cbiAqIEByZXR1cm4ge251bWJlcn0gRmlsZSBzaXplIGluIGJ5dGVzLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBnZXR0aW5nIHRoZSBzaXplIG9mIHRoZSBnaXZlbiBmaWxlLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5maWxlU2l6ZSA9IGFzeW5jIGZ1bmN0aW9uIChyZW1vdGVQYXRoKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgZmlsZXMgPSBhd2FpdCB0aGlzLmxzKHJlbW90ZVBhdGgsIFsnLWxhJ10pO1xuICAgIGlmIChmaWxlcy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUmVtb3RlIHBhdGggaXMgbm90IGEgZmlsZWApO1xuICAgIH1cbiAgICAvLyBodHRwczovL3JlZ2V4MTAxLmNvbS9yL2ZPczRQNC84XG4gICAgY29uc3QgbWF0Y2ggPSAvW3J3eHNTdFRcXC1cXCtdezEwfVtcXHNcXGRdKlxcc1teXFxzXStcXHMrW15cXHNdK1xccysoXFxkKykvLmV4ZWMoZmlsZXNbMF0pO1xuICAgIGlmICghbWF0Y2ggfHwgXy5pc05hTihwYXJzZUludChtYXRjaFsxXSwgMTApKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gcGFyc2Ugc2l6ZSBmcm9tIGxpc3Qgb3V0cHV0OiAnJHtmaWxlc1swXX0nYCk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZUludChtYXRjaFsxXSwgMTApO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBnZXQgZmlsZSBzaXplIGZvciAnJHtyZW1vdGVQYXRofSc6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gIH1cbn07XG5cbi8qKlxuICogSW5zdGFsbHMgdGhlIGdpdmVuIGNlcnRpZmljYXRlIG9uIGEgcm9vdGVkIHJlYWwgZGV2aWNlIG9yXG4gKiBhbiBlbXVsYXRvci4gVGhlIGVtdWxhdG9yIG11c3QgYmUgZXhlY3V0ZWQgd2l0aCBgLXdyaXRhYmxlLXN5c3RlbWBcbiAqIGNvbW1hbmQgbGluZSBvcHRpb24gYW5kIGFkYiBkYWVtb24gc2hvdWxkIGJlIHJ1bm5pbmcgaW4gcm9vdFxuICogbW9kZSBmb3IgdGhpcyBtZXRob2QgdG8gd29yayBwcm9wZXJseS4gVGhlIG1ldGhvZCBhbHNvIHJlcXVpcmVzXG4gKiBvcGVuc3NsIHRvb2wgdG8gYmUgYXZhaWxhYmxlIG9uIHRoZSBkZXN0aW5hdGlvbiBzeXN0ZW0uXG4gKiBSZWFkIGh0dHBzOi8vZ2l0aHViLmNvbS9hcHBpdW0vYXBwaXVtL2lzc3Vlcy8xMDk2NFxuICogZm9yIG1vcmUgZGV0YWlscyBvbiB0aGlzIHRvcGljXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ8c3RyaW5nfSBjZXJ0IC0gYmFzZTY0LWRlY29kZWQgY29udGVudCBvZiB0aGUgYWN0dWFsIGNlcnRpZmljYXRlXG4gKiByZXByZXNlbnRlZCBhcyBhIHN0cmluZyBvciBhIGJ1ZmZlclxuICogQHRocm93cyB7RXJyb3J9IElmIG9wZW5zc2wgdG9vbCBpcyBub3QgYXZhaWxhYmxlIG9uIHRoZSBkZXN0aW5hdGlvbiBzeXN0ZW1cbiAqIG9yIGlmIHRoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBpbnN0YWxsaW5nIHRoZSBjZXJ0aWZpY2F0ZVxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5pbnN0YWxsTWl0bUNlcnRpZmljYXRlID0gYXN5bmMgZnVuY3Rpb24gKGNlcnQpIHtcbiAgY29uc3Qgb3BlblNzbCA9IGF3YWl0IGdldE9wZW5Tc2xGb3JPcygpO1xuXG4gIGlmICghXy5pc0J1ZmZlcihjZXJ0KSkge1xuICAgIGNlcnQgPSBCdWZmZXIuZnJvbShjZXJ0LCAnYmFzZTY0Jyk7XG4gIH1cblxuICBjb25zdCB0bXBSb290ID0gYXdhaXQgdGVtcERpci5vcGVuRGlyKCk7XG4gIHRyeSB7XG4gICAgY29uc3Qgc3JjQ2VydCA9IHBhdGgucmVzb2x2ZSh0bXBSb290LCAnc291cmNlLmNlcicpO1xuICAgIGF3YWl0IGZzLndyaXRlRmlsZShzcmNDZXJ0LCBjZXJ0KTtcbiAgICBsZXQge3N0ZG91dH0gPSBhd2FpdCBleGVjKG9wZW5Tc2wsIFsneDUwOScsICctbm9vdXQnLCAnLWhhc2gnLCAnLWluJywgc3JjQ2VydF0pO1xuICAgIGNvbnN0IGNlcnRIYXNoID0gc3Rkb3V0LnRyaW0oKTtcbiAgICBsb2cuZGVidWcoYEdvdCBjZXJ0aWZpY2F0ZSBoYXNoOiAke2NlcnRIYXNofWApO1xuICAgIGxvZy5kZWJ1ZygnUHJlcGFyaW5nIGNlcnRpZmljYXRlIGNvbnRlbnQnKTtcbiAgICAoe3N0ZG91dH0gPSBhd2FpdCBleGVjKG9wZW5Tc2wsIFsneDUwOScsICctaW4nLCBzcmNDZXJ0XSwge2lzQnVmZmVyOiB0cnVlfSkpO1xuICAgIGxldCBkc3RDZXJ0Q29udGVudCA9IHN0ZG91dDtcbiAgICAoe3N0ZG91dH0gPSBhd2FpdCBleGVjKG9wZW5Tc2wsIFsneDUwOScsXG4gICAgICAnLWluJywgc3JjQ2VydCxcbiAgICAgICctdGV4dCcsXG4gICAgICAnLWZpbmdlcnByaW50JyxcbiAgICAgICctbm9vdXQnXSwge2lzQnVmZmVyOiB0cnVlfSkpO1xuICAgIGRzdENlcnRDb250ZW50ID0gQnVmZmVyLmNvbmNhdChbZHN0Q2VydENvbnRlbnQsIHN0ZG91dF0pO1xuICAgIGNvbnN0IGRzdENlcnQgPSBwYXRoLnJlc29sdmUodG1wUm9vdCwgYCR7Y2VydEhhc2h9LjBgKTtcbiAgICBhd2FpdCBmcy53cml0ZUZpbGUoZHN0Q2VydCwgZHN0Q2VydENvbnRlbnQpO1xuICAgIGxvZy5kZWJ1ZygnTW91bnRpbmcgL3N5c3RlbSBlbmRwb2ludCcpO1xuICAgIC8vIFNvbWV0aW1lcyBlbXVsYXRvciByZWJvb3QgaXMgc3RpbGwgbm90IGZ1bGx5IGZpbmlzaGVkIG9uIHRoaXMgc3RhZ2UsIHNvIHJldHJ5XG4gICAgYXdhaXQgcmV0cnlJbnRlcnZhbCg1LCAyMDAwLCBhc3luYyAoKSA9PiBhd2FpdCB0aGlzLnNoZWxsKFsnbW91bnQnLCAnLW8nLCAncncscmVtb3VudCcsICcvc3lzdGVtJ10pKTtcbiAgICBsb2cuZGVidWcoYFVwbG9hZGluZyB0aGUgZ2VuZXJhdGVkIGNlcnRpZmljYXRlIGZyb20gJyR7ZHN0Q2VydH0nIHRvICcke0NFUlRTX1JPT1R9J2ApO1xuICAgIGF3YWl0IHRoaXMucHVzaChkc3RDZXJ0LCBDRVJUU19ST09UKTtcbiAgICBsb2cuZGVidWcoJ1JlbW91bnRpbmcgdGhlIHJlbW90ZSBmaWxlIHN5c3RlbScpO1xuICAgIGF3YWl0IHRoaXMuYWRiRXhlYyhbJ3JlbW91bnQnXSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGluamVjdCB0aGUgY3VzdG9tIGNlcnRpZmljYXRlLiBgICtcbiAgICAgICAgICAgICAgICAgICAgYElzIHRoZSBjZXJ0aWZpY2F0ZSBwcm9wZXJseSBlbmNvZGVkIGludG8gYmFzZTY0LXN0cmluZz8gYCArXG4gICAgICAgICAgICAgICAgICAgIGBEbyB5b3UgaGF2ZSByb290IHBlcm1pc3Npb25zIG9uIHRoZSBkZXZpY2U/IGAgK1xuICAgICAgICAgICAgICAgICAgICBgT3JpZ2luYWwgZXJyb3I6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gIH0gZmluYWxseSB7XG4gICAgYXdhaXQgZnMucmltcmFmKHRtcFJvb3QpO1xuICB9XG59O1xuXG4vKipcbiAqIFZlcmlmaWVzIGlmIHRoZSBnaXZlbiByb290IGNlcnRpZmljYXRlIGlzIGFscmVhZHkgaW5zdGFsbGVkIG9uIHRoZSBkZXZpY2UuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ8c3RyaW5nfSBjZXJ0IC0gYmFzZTY0LWRlY29kZWQgY29udGVudCBvZiB0aGUgYWN0dWFsIGNlcnRpZmljYXRlXG4gKiByZXByZXNlbnRlZCBhcyBhIHN0cmluZyBvciBhIGJ1ZmZlclxuICogQHRocm93cyB7RXJyb3J9IElmIG9wZW5zc2wgdG9vbCBpcyBub3QgYXZhaWxhYmxlIG9uIHRoZSBkZXN0aW5hdGlvbiBzeXN0ZW1cbiAqIG9yIGlmIHRoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBjaGVja2luZyB0aGUgY2VydGlmaWNhdGVcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBnaXZlbiBjZXJ0aWZpY2F0ZSBpcyBhbHJlYWR5IGluc3RhbGxlZFxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5pc01pdG1DZXJ0aWZpY2F0ZUluc3RhbGxlZCA9IGFzeW5jIGZ1bmN0aW9uIChjZXJ0KSB7XG4gIGNvbnN0IG9wZW5Tc2wgPSBhd2FpdCBnZXRPcGVuU3NsRm9yT3MoKTtcblxuICBpZiAoIV8uaXNCdWZmZXIoY2VydCkpIHtcbiAgICBjZXJ0ID0gQnVmZmVyLmZyb20oY2VydCwgJ2Jhc2U2NCcpO1xuICB9XG5cbiAgY29uc3QgdG1wUm9vdCA9IGF3YWl0IHRlbXBEaXIub3BlbkRpcigpO1xuICBsZXQgY2VydEhhc2g7XG4gIHRyeSB7XG4gICAgY29uc3QgdG1wQ2VydCA9IHBhdGgucmVzb2x2ZSh0bXBSb290LCAnc291cmNlLmNlcicpO1xuICAgIGF3YWl0IGZzLndyaXRlRmlsZSh0bXBDZXJ0LCBjZXJ0KTtcbiAgICBjb25zdCB7c3Rkb3V0fSA9IGF3YWl0IGV4ZWMob3BlblNzbCwgWyd4NTA5JywgJy1ub291dCcsICctaGFzaCcsICctaW4nLCB0bXBDZXJ0XSk7XG4gICAgY2VydEhhc2ggPSBzdGRvdXQudHJpbSgpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCByZXRyaWV2ZSB0aGUgY2VydGlmaWNhdGUgaGFzaC4gYCArXG4gICAgICAgICAgICAgICAgICAgIGBJcyB0aGUgY2VydGlmaWNhdGUgcHJvcGVybHkgZW5jb2RlZCBpbnRvIGJhc2U2NC1zdHJpbmc/IGAgK1xuICAgICAgICAgICAgICAgICAgICBgT3JpZ2luYWwgZXJyb3I6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gIH0gZmluYWxseSB7XG4gICAgYXdhaXQgZnMucmltcmFmKHRtcFJvb3QpO1xuICB9XG4gIGNvbnN0IGRzdFBhdGggPSBwYXRoLnBvc2l4LnJlc29sdmUoQ0VSVFNfUk9PVCwgYCR7Y2VydEhhc2h9LjBgKTtcbiAgbG9nLmRlYnVnKGBDaGVja2luZyBpZiB0aGUgY2VydGlmaWNhdGUgaXMgYWxyZWFkeSBpbnN0YWxsZWQgYXQgJyR7ZHN0UGF0aH0nYCk7XG4gIHJldHVybiBhd2FpdCB0aGlzLmZpbGVFeGlzdHMoZHN0UGF0aCk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBzeXN0ZW1DYWxsTWV0aG9kcztcbiJdLCJzb3VyY2VSb290IjoiLi4vLi4vLi4ifQ==
